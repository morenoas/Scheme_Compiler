diff --git a/code-gen.ml b/code-gen.ml
index dd80017..a07f0dd 100644
--- a/code-gen.ml
+++ b/code-gen.ml
@@ -1,3 +1,18 @@
+
+
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+
+
+
+
+
 #use "semantic-analyser.ml";;
 
 (* This module is here for you convenience only!
@@ -32,8 +47,682 @@ module type CODE_GEN = sig
 end;;
 
 module Code_Gen : CODE_GEN = struct
-  let make_consts_tbl asts = raise X_not_yet_implemented;;
-  let make_fvars_tbl asts = raise X_not_yet_implemented;;
-  let generate consts fvars e = raise X_not_yet_implemented;;
+
+
+exception X_syntax_error;;
+exception X_syntax_error1;;
+exception X_syntax_error2;;
+
+
+
+
+
+(* deletes duplications in l *)
+  let rec makeSet l s = match l with
+                    | [] -> [] 
+                    | [a] -> if List.exists (fun e-> a = e) s then s else s @ [a]
+                    | a::b -> if List.exists (fun e-> a = e) s then makeSet b s else makeSet b (s @ [a])
+                    (* | _-> raise X_syntax_error1 *)
+  ;;
+  let rec makeConstsTablePerAST ast l = 
+      match ast with
+      | Const'(e) -> l @ [e]
+      | Var'(_) | Box'(_) | BoxGet'(_) -> []
+      | BoxSet'(_,exp) -> makeConstsTablePerAST exp l
+      | If'(test, dit, dif) -> l @ (makeConstsTablePerAST test []) @ (makeConstsTablePerAST dit []) @ (makeConstsTablePerAST dif [])
+      | Seq'(exps) -> List.fold_left (fun l1 l2 -> l1 @ (makeConstsTablePerAST l2 [])) l exps
+      | Set'(_,exp) -> makeConstsTablePerAST exp l
+      | Def'(_, exp) -> makeConstsTablePerAST exp l
+      | Or'(exps) -> List.fold_left (fun l1 l2 -> l1 @ (makeConstsTablePerAST l2 [])) l exps
+      | LambdaSimple'(args, body) -> makeConstsTablePerAST body l
+      | LambdaOpt'(args, last, body) -> makeConstsTablePerAST body l
+      | Applic'(e, exps) -> (makeConstsTablePerAST e []) @ (List.fold_left (fun l1 l2 -> l1 @ (makeConstsTablePerAST l2 [])) l exps)
+      | ApplicTP'(e, exps) -> (makeConstsTablePerAST e []) @ (List.fold_left (fun l1 l2 -> l1 @ (makeConstsTablePerAST l2 [])) l exps)
+  ;;
+(* gets the offset of constant c in constants table*)
+let rec getOffSet (c: sexpr) l = 
+      match l with
+      | [(Sexpr(se), (y, z))] -> if sexpr_eq se c then y else raise X_this_should_not_happen
+      | (Void, (y, z))::b-> getOffSet c b 
+      | (Sexpr(se), (y, z))::b-> if sexpr_eq se c then y else getOffSet c b 
+      | _-> raise X_syntax_error
+;;
+
+let string_to_ascii_list str =
+    let chars = string_to_list str in
+    let asciis = List.map Char.code chars in
+    let ascii_strs = List.map (Printf.sprintf "%d") asciis in
+    String.concat "," ascii_strs;;
+
+(* %macro MAKE_LITERAL_STRING 1
+	db T_STRING
+	dq (%%end_str - %%str)
+%%str:
+	db %1
+%%end_str:
+%endmacro *)
+
+let make_unique_index label = 
+    let last = ref (-1) in 
+    (fun needToInc -> 
+        if needToInc then incr last ;
+        label ^ string_of_int !last)
+    ;;
+
+  let make_unique_str = make_unique_index "str" ;;
+  let make_unique_end_str = make_unique_index "end_str" ;;
+
+(* turns [sexpr1; sexpr2] into [(sexpr1, (0, "assembly code")); (sexpr2, (1, "assembly code"))] 
+    nl = new list*)
+  let rec getInternalConstsTable l i nl = 
+
+    let labal_str_inc = make_unique_str true in
+    let labal_str_no_inc = make_unique_str false in
+    let labal_end_str_inc = make_unique_end_str true in
+    let labal_end_str_no_inc = make_unique_end_str false in
+
+      match l with
+      | [] -> nl
+      | [a] -> (match a with
+                | Sexpr(Number(Fraction(num, denom))) -> nl @ [(a, (i, "MAKE_LITERAL_RATIONAL("^string_of_int num^", "^string_of_int denom^")"))]
+                | Sexpr(Number(Float(f))) -> nl @ [(a, (i, "MAKE_LITERAL_FLOAT("^string_of_float f^")"))]
+                | Sexpr(Char(c)) -> nl @ [(a, (i, "MAKE_LITERAL_CHAR("^string_of_int (Char.code c)^")"))] 
+                | Sexpr(String(s)) -> 
+                                    if (String.length s) = 0 
+                                    then nl @ [(a, (i, "db T_STRING\n" ^
+                                                       "dq ("^ labal_end_str_inc ^" - "^ labal_str_inc ^")\n" ^
+                                                       labal_str_no_inc ^":\n" ^
+                                                       "db \"\"\n" ^
+                                                       labal_end_str_no_inc ^":\n"))]
+                                    else
+                                        nl @ [(a, (i,
+                                                      "db T_STRING\n" ^
+                                                      "dq ("^ labal_end_str_inc ^" - "^ labal_str_inc ^")\n" ^
+                                                      labal_str_no_inc ^":\n" ^
+                                                      "db "^ string_to_ascii_list s ^"\n" ^
+                                                      labal_end_str_no_inc ^":\n"))]
+
+                | Sexpr(Symbol(s)) -> nl @ [(a, (i, "MAKE_LITERAL_SYMBOL(const_tbl+"^string_of_int (getOffSet (String(s)) nl)^")"))] 
+                | Sexpr(Pair(car,cdr)) -> nl @ [a, (i, "MAKE_LITERAL_PAIR(const_tbl+"^string_of_int (getOffSet car nl)^", const_tbl+"^string_of_int (getOffSet cdr nl)^")")] 
+                | _-> raise X_syntax_error)
+      | a::b -> (match a with
+                | Sexpr(Number(Fraction(num, denom))) -> getInternalConstsTable b (i+17) (nl @ [(a, (i, "MAKE_LITERAL_RATIONAL("^string_of_int num^", "^string_of_int denom^")"))])
+                | Sexpr(Number(Float(f))) -> getInternalConstsTable b (i+9) (nl @ [(a, (i, "MAKE_LITERAL_FLOAT("^string_of_float f^")"))])
+                | Sexpr(Char(c)) -> getInternalConstsTable b (i+2) (nl @ [(a, (i, "MAKE_LITERAL_CHAR("^string_of_int (Char.code c)^")"))])
+                | Sexpr(String(s)) -> 
+                                    if (String.length s) = 0 
+                                    then getInternalConstsTable b (i+9+ (String.length s))  (nl @ [(a, (i, "db T_STRING\n" ^
+                                                                                                           "dq ("^ labal_end_str_inc ^" - "^ labal_str_inc ^")\n" ^
+                                                                                                           labal_str_no_inc ^":\n" ^
+                                                                                                           "db \"\"\n" ^
+                                                                                                           labal_end_str_no_inc ^":\n"))])
+                                    else
+                                        getInternalConstsTable b (i+9+ (String.length s))  (nl @ [(a, (i,
+                                                                                                         "db T_STRING\n" ^
+                                                                                                         "dq ("^ labal_end_str_inc ^" - "^ labal_str_inc ^")\n" ^
+                                                                                                         labal_str_no_inc ^":\n" ^
+                                                                                                         "db "^ string_to_ascii_list s ^"\n" ^
+                                                                                                         labal_end_str_no_inc ^":\n"))])
+                
+                | Sexpr(Symbol(s)) -> getInternalConstsTable b (i+9) (nl @ [(a, (i, "MAKE_LITERAL_SYMBOL(const_tbl+"^string_of_int (getOffSet (String(s)) nl)^")"))])
+                | Sexpr(Pair(car,cdr)) -> getInternalConstsTable b (i+17) (nl @ [a, (i, "MAKE_LITERAL_PAIR(const_tbl+"^string_of_int (getOffSet car nl)^", const_tbl+"^string_of_int (getOffSet cdr nl)^")")]) 
+                | _-> raise X_syntax_error)
+      (* | _-> raise X_syntax_error *)
+  ;;
+
+(* [Sexpr (String "a"), Sexpr (Symbol "a")] *)
+
+(* (list "ab" '(1 2) ) *)
+  let rec getSubConsts c =
+      match c with 
+      | Sexpr(Pair(car, cdr)) -> (getSubConsts (Sexpr(car))) @ (getSubConsts (Sexpr(cdr))) @ [c]
+      | Sexpr(Symbol(s)) -> [Sexpr(String(s)); c]
+      | Sexpr(_) -> [c]
+      | Void -> []
+      (* | _-> raise X_syntax_error1 *)
+  ;;
+  (* deletes | Void
+             | Sexpr(Nil)
+             | Sexpr(Bool false)
+             | Sexpr(Bool true)     from s *)
+  let rec remove_initial_from_constsTable s = 
+      match s with 
+      | [] -> []
+      | [a] -> ( match a with 
+                | Void -> []
+                | Sexpr(Nil) -> []
+                | Sexpr(Bool false) -> []
+                | Sexpr(Bool true) -> []
+                | _-> [a])
+      | a::b -> ( match a with 
+                | Void -> remove_initial_from_constsTable b
+                | Sexpr(Nil) -> remove_initial_from_constsTable b
+                | Sexpr(Bool false) -> remove_initial_from_constsTable b
+                | Sexpr(Bool true) -> remove_initial_from_constsTable b
+                | _-> [a] @ remove_initial_from_constsTable b)
+      (* | _-> raise X_syntax_error1 *)
+  ;;
+
+  let make_consts_tbl asts = 
+      let constsTable_notSet = List.flatten (List.map (fun ast -> makeConstsTablePerAST ast []) asts) in
+      let constsTableSet_withoutSubs = makeSet constsTable_notSet [] in
+      let constsTable_withSubs = List.fold_left (fun l1 c -> l1 @ (getSubConsts c)) [] constsTableSet_withoutSubs in (* subs means sub constants *)
+      let constsTableSet = makeSet constsTable_withSubs [] in
+      let constsTableSet_whitoutSome = remove_initial_from_constsTable constsTableSet in
+      let initial_internalConstsTable = [(Void, (0, "db T_VOID"));
+                                         (Sexpr(Nil), (1, "db T_NIL"));
+                                         (Sexpr(Bool false), (2, "db T_BOOL, 0"));
+                                         (Sexpr(Bool true), (4, "db T_BOOL, 1"))] in
+      let internalConstsTable = getInternalConstsTable constsTableSet_whitoutSome 6 initial_internalConstsTable in
+      internalConstsTable
+  ;;
+
+  let rec makefVarsNameTablePerAST ast l = 
+      match ast with
+      | Var'(VarFree(name)) -> l @ [name]
+      | Box'(VarFree(name)) -> l @ [name]
+      | BoxGet'(VarFree(name)) -> l @ [name]
+      | BoxSet'(VarFree(name),exp) -> makefVarsNameTablePerAST exp (l @ [name])
+      | Set'(VarFree(name),exp) -> makefVarsNameTablePerAST exp (l @ [name])
+      | Def'(VarFree(name),exp) -> makefVarsNameTablePerAST exp (l @ [name])
+      | BoxSet'(_,exp) -> makefVarsNameTablePerAST exp l  (* cases not varFree but maybe a varfree in exp *)
+      | Set'(_,exp) -> makefVarsNameTablePerAST exp l
+      | Def'(_,exp) -> makefVarsNameTablePerAST exp l
+      | If'(test, dit, dif) -> l @ (makefVarsNameTablePerAST test []) @ (makefVarsNameTablePerAST dit []) @ (makefVarsNameTablePerAST dif [])
+      | Seq'(exps) -> List.fold_left (fun l1 l2 -> l1 @ (makefVarsNameTablePerAST l2 [])) l exps
+      | Or'(exps) -> List.fold_left (fun l1 l2 -> l1 @ (makefVarsNameTablePerAST l2 [])) l exps
+      | LambdaSimple'(args, body) -> makefVarsNameTablePerAST body l
+      | LambdaOpt'(args, last, body) -> makefVarsNameTablePerAST body l
+      | Applic'(e, exps) -> (makefVarsNameTablePerAST e []) @ (List.fold_left (fun l1 l2 -> l1 @ (makefVarsNameTablePerAST l2 [])) l exps)
+      | ApplicTP'(e, exps) -> (makefVarsNameTablePerAST e []) @ (List.fold_left (fun l1 l2 -> l1 @ (makefVarsNameTablePerAST l2 [])) l exps)
+      | _-> l
+  ;;
+
+
+  (* turns ["a"; "b"] into [("a", 0); ("b", 1)] *)
+  let rec getInternalfVarsTable nameList i = match nameList with
+                                            | [] -> []
+                                            | [a] -> [(a, i)]
+                                            | a::b -> [(a, i)] @ (getInternalfVarsTable b (i+1))
+                                            (* | _-> raise X_syntax_error *)
+  ;;
+
+  
+
+  let make_fvars_tbl asts =
+    let fVarsNameTableNotSet = ["boolean?"; "flonum?"; "rational?";
+                                "pair?"; "null?"; "char?"; "string?";
+                                "procedure?"; "symbol?";
+                                "string-length"; "string-ref"; "string-set!";
+                                "make-string"; "symbol->string";
+                                "char->integer"; "integer->char"; "exact->inexact";
+                                "eq?";
+                                "+"; "*"; "/"; "="; "<";
+                                "numerator"; "denominator"; "gcd";
+                                "car"; "cdr"; "cons"; "set-car!"; "set-cdr!"; "apply"] 
+                                @ List.flatten (List.map (fun ast -> makefVarsNameTablePerAST ast []) asts) in
+    let fVarsNameTable = makeSet fVarsNameTableNotSet [] in
+    let internalfVarsTable = getInternalfVarsTable fVarsNameTable 0 in
+    internalfVarsTable
+  ;;
+
+
+  
+  (* for if and or *)
+  let make_unique_Lexit = make_unique_index "Lexit" ;;
+  let make_unique_Lelse = make_unique_index "Lelse" ;;
+  (* for adjust_stack *)
+  let make_unique_enlargeStack = make_unique_index "enlarge_stack" ;;
+  let make_unique_shrinkStack = make_unique_index "shrink_stack" ;;
+  let make_unique_replaceArgsEnlarge = make_unique_index "replace_args_enlarge" ;;
+  let make_unique_AfterReplaceArgsEnlarge = make_unique_index "after_replace_args_enlarge" ;;
+  let make_unique_replaceArgsShrink = make_unique_index "replace_args_shrink" ;;
+  (* let make_unique_AfterReplaceArgsShrink = make_unique_index "after_replace_args_shrink" in *)
+  let make_unique_createList = make_unique_index "create_list" ;;
+  let make_unique_finishAdjust = make_unique_index "finish_adjust" ;;
+  (* for lambda simple and opt *)
+  let make_unique_cpyMinVec = make_unique_index "copy_minor_vectors" ;;
+  let make_unique_AftercpyMinVec = make_unique_index "after_copy_minor_vectors" ;;
+  let make_unique_cpyParams = make_unique_index "copy_params" ;;
+  let make_unique_AftercpyParams = make_unique_index "after_copy_params" ;;
+  let make_unique_Lcode = make_unique_index "Lcode" ;;
+  let make_unique_Lcont = make_unique_index "Lcont" ;;
+  (* for lambda opt *)
+  let make_unique_adjustStuck = make_unique_index "adjust_stack_Lopt" ;;
+  (* for applic *)
+  let make_unique_procIsClosure = make_unique_index "proc_is_a_Closure" ;;
+  (* for applicTP *)
+  let make_unique_procIsClosure = make_unique_index "proc_is_a_Closure" ;;
+  let make_unique_replaceFramesTP = make_unique_index "replace_frames_TP" ;;
+
+  
+  let adjust_stack args last body =
+    let labal_enlargeStack_inc = make_unique_enlargeStack true in
+    let labal_enlargeStack_no_inc = make_unique_enlargeStack false in
+
+    let label_shrinkStack_inc = make_unique_shrinkStack true in
+    (* let label_shrinkStack_no_inc = make_unique_shrinkStack false in *)
+
+    let label_replaceArgsEnlarge_inc = make_unique_replaceArgsEnlarge true in
+    let label_replaceArgsEnlarge_no_inc = make_unique_replaceArgsEnlarge false in
+
+    let label_AfterReplaceArgsEnlarge_inc = make_unique_AfterReplaceArgsEnlarge true in
+    let label_AfterReplaceArgsEnlarge_no_inc = make_unique_AfterReplaceArgsEnlarge false in
+
+    let label_replaceArgsShrink_inc = make_unique_replaceArgsShrink true in
+    let label_replaceArgsShrink_no_inc = make_unique_replaceArgsShrink false in
+
+    (* let make_unique_AfterReplaceArgsShrink = make_unique_index "after_replace_args_shrink" in *)
+    let label_createList_inc = make_unique_createList true in
+    let label_createList_no_inc = make_unique_createList false in
+
+    let label_finishAdjust_inc = make_unique_finishAdjust true in
+    let label_finishAdjust_no_inc = make_unique_finishAdjust false in
+
+
+      "mov rcx, [rsp + 2 * WORD_SIZE]\n\t\t\t" ^      (* rcx <- n *)
+      "cmp rcx, "^ string_of_int (List.length args) ^"\n\t\t\t" ^
+      "je "^ labal_enlargeStack_inc ^"\n\t\t\t" ^
+(* shrink stack *)
+      label_shrinkStack_inc ^":\n\t\t\t\t" ^
+      (* creating the opt list *)
+      "mov rax, SOB_NIL_ADDRESS\n\t\t\t\t" ^                               (* rax <- cdr *)
+      "mov rcx, [rsp + 2 * WORD_SIZE]\n\t\t\t\t" ^                         (* rcx <- n *)
+      "sub rcx, "^ string_of_int (List.length args) ^"\n\t\t\t\t" ^        (* rcx <- n - arg.length *)
+      label_createList_inc ^":\n\t\t\t\t\t" ^
+      "mov rbx, [rsp + (2 + "^ string_of_int (List.length args) ^" + rcx) * WORD_SIZE]\n\t\t\t\t\t" ^               (* rbx <- car *)
+      "MAKE_PAIR(rdx, rbx, rax)\n\t\t\t\t\t" ^              
+      "mov rax, rdx \n\t\t\t\t\t" ^                                        (* rax <- new cdr *)
+      "loop "^ label_createList_no_inc ^"\n\t\t\t\t" ^
+      (* putting the opt list in its place in stack*)
+      "mov [rsp + (2 + 1 + "^ string_of_int (List.length args) ^") * WORD_SIZE], rax\n\t\t\t\t" ^
+
+      (* moving all args on stack n-(args.length+1) cells in *)
+      "mov rbx, [rsp + 2 * WORD_SIZE]\n\t\t\t\t" ^                           (* rbx <- n *)
+      "sub rbx, "^ string_of_int (List.length args) ^" + 1\n\t\t\t\t" ^      (* rbx <- n - (args.length+1) *)
+      "mov rcx, 3 + "^ string_of_int (List.length args) ^" + 1\n\t\t\t\t" ^  (* rcx <- number of cells to replace = ret,env,n + args.length + opt list *)
+      label_replaceArgsShrink_inc ^":\n\t\t\t\t\t" ^
+      "mov rdx, [rsp + (rcx-1) * WORD_SIZE] \n\t\t\t\t\t" ^
+
+      "mov r8, rcx \n\t\t\t\t\t" ^
+      "add r8, rbx \n\t\t\t\t\t" ^
+      "dec r8\n\t\t\t\t\t" ^
+      "mov [rsp + r8 * WORD_SIZE], rdx\n\t\t\t\t\t" ^
+      "loop "^ label_replaceArgsShrink_no_inc ^"\n\t\t\t\t" ^
+
+      (* changing the rsp *)
+      "shl rbx, 3 \n\t\t\t\t" ^
+      "add rsp, rbx \n\t\t\t\t" ^    (* to verify that rbx is the right offset to change rsp ============== *)
+
+      (* changing n to be args.length+1 *)
+      "mov qword [rsp + 2 * WORD_SIZE], "^ string_of_int ((List.length args)+1) ^"\n\t\t\t\t" ^
+      (* finish shrink stack so jumping to end *)
+      "jmp "^ label_finishAdjust_inc ^"\n\t\t\t" ^
+      
+(* enlarge stack *)
+      (* inserts new_args_number to its place on stack *)
+      labal_enlargeStack_no_inc ^":\n\t\t\t\t" ^
+      "pop rax\n\t\t\t\t" ^   (* rax <- ret *)
+      "pop rbx\n\t\t\t\t" ^   (* rbx <- env *)
+      "push "^ string_of_int ((List.length args)+1) ^"\n\t\t\t\t" ^
+      "push rbx\n\t\t\t\t" ^
+      "push rax\n\t\t\t\t" ^
+
+      (* moving all args on stack 1 cell out *)
+      "mov rcx, 1\n\t\t\t" ^
+      label_replaceArgsEnlarge_inc ^":\n\t\t\t\t" ^
+      "cmp rcx, "^ string_of_int (List.length args) ^"\n\t\t\t\t" ^     (* looping for number of args (without last one) *)
+      "jg "^ label_AfterReplaceArgsEnlarge_inc ^"\n\t\t\t\t" ^
+
+      
+      "mov rdx, [rsp + (3 + rcx) * WORD_SIZE]\n\t\t\t\t" ^          (* 3 to get to point on n *)
+      "mov [rsp + (3 + rcx -1) * WORD_SIZE], rdx\n\t\t\t\t" ^
+      "add rcx, 1\n\t\t\t\t" ^
+      "jmp "^ label_replaceArgsEnlarge_no_inc ^"\n\t\t\t" ^
+
+      label_AfterReplaceArgsEnlarge_no_inc ^":\n\t\t\t\t" ^
+      (* put () in the end of the stack *)
+      "mov rax, SOB_NIL_ADDRESS\n\t\t\t\t" ^
+      "mov [rsp + (3 + "^ string_of_int (List.length args) ^") * WORD_SIZE], rax\n\t\t\t" ^
+      (* finish enlarge stack *)
+      label_finishAdjust_no_inc ^ ":\n"
+  ;;
+
+
+  let rec gen consts fvars e env_size = 
+      match e with
+      | Const'(c) -> "mov rax, const_tbl+"^ string_of_int(fst (List.assoc c consts)) ^" ;; Const'(c)\n"
+      | Var'(VarFree(s)) -> "mov rax, qword [fvar_tbl+"^ string_of_int(List.assoc s fvars) ^" * 8]  ;; Var'(VarFree(s))\n"
+      | Var'(VarParam(_, min)) -> 
+                                  (* "mov rax, qword [rbp + 8 ∗ (4 + "^ string_of_int min ^")]\n" *)
+                                  "mov rax, "^ string_of_int min ^" ;; Var'(VarParam(_, min))\n" ^
+                                  "add rax, 4\n" ^
+                                  "shl rax, 3\n" ^
+                                  "add rax, rbp\n" ^
+                                  "mov rax, qword [rax]\n"
+      | Var'(VarBound(_, maj, min)) -> 
+                                        (* "mov rax, qword [rbp + 8 ∗ 2]\n\t" ^ *)
+                                        "mov r8, 2  ;; Var'(VarBound(_, maj, min))\n\t" ^
+                                        "shl r8, 3\n\t" ^
+                                        "add r8, rbp\n\t" ^
+                                        "mov rax, qword [r8]\n\t" ^
+
+                                        (* "mov rax, qword [rax + 8 ∗ "^ string_of_int maj ^"]\n\t" ^ *)
+                                        "mov r8, "^ string_of_int maj ^"\n\t" ^
+                                        "shl r8, 3\n\t" ^
+                                        "add r8, rax\n\t" ^
+                                        "mov rax, qword [r8]\n\t" ^
+
+                                        (* "mov rax, qword [rax + 8 ∗ "^ string_of_int min ^"]\n"  *)
+                                        "mov r8, "^ string_of_int min ^"\n\t" ^
+                                        "shl r8, 3\n\t" ^
+                                        "add r8, rax\n\t" ^
+                                        "mov rax, qword [r8]\n\t"
+
+      | Box'(v) -> gen consts fvars (Var'(v)) env_size ^
+                   "\tMALLOC rbx, WORD_SIZE ;; Box'(v)\n\t" ^
+                    "mov [rbx], rax\n\t" ^
+                    "mov rax, rbx\n" 
+      | BoxGet'(v) -> ";; BoxGet'(v)\n" ^ 
+                      gen consts fvars (Var'(v)) env_size ^
+                      "\tmov rax, qword [rax]\n"
+      | BoxSet'(v,exp) -> ";; BoxSet'(v,exp)\n" ^
+                          gen consts fvars exp env_size ^
+                          "\tpush rax\n\t" ^
+                           gen consts fvars (Var'(v)) env_size ^
+                          "\tpop qword [rax]\n\t" ^
+                           "mov rax, SOB_VOID_ADDRESS\n" 
+      | If'(test, dit, dif) -> 
+        let lelse_inc = make_unique_Lelse true in
+        let lelse_no_inc = make_unique_Lelse false in
+        let lexit_inc = make_unique_Lexit true in
+        let lexit_no_inc = make_unique_Lexit false in
+                                ";; If'(test, dit, dif)\n" ^
+                                gen consts fvars test env_size ^
+                               "\tcmp rax, SOB_FALSE_ADDRESS\n\t" ^
+                               "je "^ lelse_inc ^"\n" ^   
+                                gen consts fvars dit env_size ^
+                               "\tjmp "^ lexit_inc ^"\n\t" ^    
+                                lelse_no_inc ^":\n\t" ^ 
+                                gen consts fvars dif env_size ^ "\t" ^
+                                lexit_no_inc ^":\n"       
+
+      | Seq'(exps) -> List.fold_left (fun str e -> str ^ (gen consts fvars e env_size) ^ "\n\t") "\t" exps
+      | Set'(VarFree(s),exp) -> ";; Set'(VarFree(s),exp)\n" ^
+                                (gen consts fvars exp env_size) ^
+                                "\tmov qword [fvar_tbl+"^ string_of_int(List.assoc s fvars) ^" * 8], rax\n\t" ^
+                                 "mov rax, SOB_VOID_ADDRESS\n" 
+      | Set'(VarParam(_, min),exp) -> ";; Set'(VarParam(_, min),exp)\n" ^
+                                (gen consts fvars exp env_size) ^
+                                (* "\tmov qword [rbp + 8 ∗ (4 + "^string_of_int min^")], rax\n\t" ^ *)
+                                "\tmov r8, "^string_of_int min^"\n\t" ^
+                                "\tadd r8, 4\n\t" ^
+                                "\tshl r8, 3\n\t" ^
+                                "\tadd r8, rbp\n\t" ^
+                                "\tmov qword [r8], rax\n\t" ^
+
+                                 "mov rax, SOB_VOID_ADDRESS\n"
+      | Set'(VarBound(_, maj, min),exp) -> ";; Set'(VarBound(_, maj, min),exp)\n" ^
+                                (gen consts fvars exp env_size) ^
+                                "\tmov rbx, qword [rbp + 8 ∗ 2]\n\t" ^
+                                 "mov rbx, qword [rbx + 8 ∗ "^string_of_int maj^"]\n\t" ^
+                                 "mov qword [rbx + 8 ∗ "^string_of_int min^"], rax\n\t" ^
+                                 "mov rax, SOB_VOID_ADDRESS\n"
+      | Def'(VarFree(s),exp) -> ";; Def'(VarFree(s),exp)\n" ^
+                       gen consts fvars exp env_size ^
+                       "\tmov qword [fvar_tbl+"^ string_of_int(List.assoc s fvars) ^ " * WORD_SIZE], rax\n\t" ^
+                       "mov rax, SOB_VOID_ADDRESS\n"
+      | Or'(exps) -> 
+          let lexit_inc = make_unique_Lexit true in
+          let lexit_no_inc = make_unique_Lexit false in
+
+          let exps_withoutFirstLast = List.tl (List.rev (List.tl (List.rev exps))) in
+          let first = List.hd exps in
+          let last = List.hd(List.rev exps) in
+                                              (gen consts fvars first env_size) ^     (* gen 1st exp *)
+                                              "\tcmp rax, SOB_FALSE_ADDRESS\n\t" ^
+                                              "jne "^ lexit_inc ^"\n\t" ^
+          (List.fold_left (fun str e -> str ^ (gen consts fvars e env_size) ^         (* gen middle exps *)
+                                              "cmp rax, SOB_FALSE_ADDRESS\n" ^
+                                              "jne "^ lexit_no_inc ^"\n\t") "" exps_withoutFirstLast) ^
+                                              (gen consts fvars last env_size) ^      (* gen last exp *)
+                                              "\t" ^ lexit_no_inc ^":\n"      
+
+      | LambdaSimple'(args, body) -> 
+          let label_cpyMinVec_inc = make_unique_cpyMinVec true in
+          let label_cpyMinVec_no_inc = make_unique_cpyMinVec false in
+
+          let label_AftercpyMinVec_inc = make_unique_AftercpyMinVec true in
+          let label_AftercpyMinVec_no_inc = make_unique_AftercpyMinVec false in
+
+          let label_cpyParams_inc = make_unique_cpyParams true in
+          let label_cpyParams_no_inc = make_unique_cpyParams false in
+
+          let label_AftercpyParams_inc = make_unique_AftercpyParams true in
+          let label_AftercpyParams_no_inc = make_unique_AftercpyParams false in
+
+          let label_Lcode_inc = make_unique_Lcode true in
+          let label_Lcode_no_inc = make_unique_Lcode false in
+
+          let label_Lcont_inc = make_unique_Lcont true in
+          let label_Lcont_no_inc = make_unique_Lcont false in
+
+              "MALLOC rax, WORD_SIZE * "^ string_of_int (1+ env_size) ^" ;; allocates mem for extEnv, rax <- pointer to extEnv \n\t" ^
+              "mov rbx, [rbp + 2 * WORD_SIZE]        ;; rbx <- pointer to the array of all envs \n\t" ^
+              "mov rcx, "^ string_of_int env_size ^" ;; rcx <- size of env \n\t" ^
+              "cmp rcx, 0\n\t" ^
+              "jle "^ label_AftercpyMinVec_inc ^"\n\t" ^
+
+              label_cpyMinVec_inc ^":                ;; copying the pointers minor vectors from env to extEnv \n\t\t" ^
+              "mov rdx, [rbx + (rcx-1) * WORD_SIZE]\n\t\t" ^
+              "mov [rax + rcx * WORD_SIZE], rdx\n\t\t" ^
+              "loop "^ label_cpyMinVec_no_inc ^"\n\t" ^
+
+              label_AftercpyMinVec_no_inc ^":\n\t" ^
+              "\tmov rcx, [rbp + 3 * WORD_SIZE]     ;; rcx <- number of params \n\t" ^
+              (* "\tmov rcx, [rsp]                     ;; rcx <- number of params (this is the last thing on stack after applic pushes this) \n\t" ^ *)
+              "mov r8, SOB_NIL_ADDRESS              ;; in case there are no params \n\t" ^
+              "cmp rcx, 0\n\t" ^
+              "jle "^ label_AftercpyParams_inc ^"\n\t" ^    
+              "\tmov r9, rcx                        ;; r9 <- rcx \n\t" ^
+              "\tshl r9, 3                         ;; r9 is multiplied by WORD_SIZE \n\t" ^
+              "MALLOC r8, r9                       ;; allocates mem for extEnv[0], r8 <- pointer to extEnv[0] \n\t" ^
+
+              label_cpyParams_inc ^":               ;; copying the params from env to extEnv[0] \n\t\t" ^
+              "mov rdx, [rbp + (3+rcx) * WORD_SIZE]\n\t\t" ^
+              (* "mov rdx, [rsp + rcx * WORD_SIZE]\n\t\t" ^ *)
+              "mov [r8 + (rcx-1) * WORD_SIZE], rdx\n\t\t" ^
+              "loop "^ label_cpyParams_no_inc ^"\n\t" ^
+
+              label_AftercpyParams_no_inc ^":\n\t" ^
+              "\tmov [rax + 0 * WORD_SIZE], r8      ;; put pointer to extEnv[0] in dedicated address, rax now holds the pointer to full extEnv \n\t" ^
+              "mov rbx, rax                         ;; rbx <- rax \n\t" ^
+              "MAKE_CLOSURE(rax, rbx, "^ label_Lcode_inc ^")\n\t" ^
+              "jmp "^ label_Lcont_inc ^"\n\t" ^ 
+
+              label_Lcode_no_inc ^":                ;; Lcode for the closure \n\t\t" ^
+              "push rbp\n\t\t" ^
+              "mov rbp, rsp\n\t\t" ^
+              gen consts fvars body (env_size+1) ^
+              "\t\tleave\n\t\t" ^
+              "ret\n\t" ^
+
+              label_Lcont_no_inc ^":\n"
+
+      | LambdaOpt'(args, last, body) -> 
+          let label_cpyMinVec_inc = make_unique_cpyMinVec true in
+          let label_cpyMinVec_no_inc = make_unique_cpyMinVec false in
+
+          let label_AftercpyMinVec_inc = make_unique_AftercpyMinVec true in
+          let label_AftercpyMinVec_no_inc = make_unique_AftercpyMinVec false in
+
+          let label_cpyParams_inc = make_unique_cpyParams true in
+          let label_cpyParams_no_inc = make_unique_cpyParams false in
+
+          let label_AftercpyParams_inc = make_unique_AftercpyParams true in
+          let label_AftercpyParams_no_inc = make_unique_AftercpyParams false in
+
+          let label_Lcode_inc = make_unique_Lcode true in
+          let label_Lcode_no_inc = make_unique_Lcode false in
+
+          let label_Lcont_inc = make_unique_Lcont true in
+          let label_Lcont_no_inc = make_unique_Lcont false in
+
+          let label_adjustStuck_inc = make_unique_adjustStuck true in
+      
+              "MALLOC rax, WORD_SIZE * "^ string_of_int (1+ env_size) ^"\n\t" ^ (* allocates mem for extEnv *)
+              "mov rbx, [rbp + 2 * WORD_SIZE]\n\t" ^
+              "mov rcx, "^ string_of_int env_size ^"\n\t" ^ (* rcx <- size of env *)
+              "cmp rcx, 0\n\t" ^
+              "jle "^ label_AftercpyMinVec_inc ^"\n\t" ^
+
+              label_cpyMinVec_inc ^":\n\t\t" ^         (* copying the pointers minor vectors from env to extEnv *)
+              "mov rdx, [rbx + (rcx-1) * WORD_SIZE]\n\t\t" ^
+              "mov [rax + rcx * WORD_SIZE], rdx\n\t\t" ^
+              "loop "^ label_cpyMinVec_no_inc ^"\n\t" ^
+
+              label_AftercpyMinVec_no_inc ^":\n\t" ^
+              "\tmov rcx, [rbp + 3 * WORD_SIZE]\n\t" ^      (* rcx <- number of params *)
+              "mov r8, SOB_NIL_ADDRESS\n\t" ^              (* in case there are no params *)
+              "cmp rcx, 0\n\t" ^
+              "jle "^ label_AftercpyParams_inc ^"\n\t" ^
+              "\tmov r9, rcx                        ;; r9 <- rcx \n\t" ^
+              "\tshl r9, 3                         ;; r9 is multiplied by WORD_SIZE \n\t" ^
+              "MALLOC r8, r9                       ;; allocates mem for extEnv[0], r8 <- pointer to extEnv[0] \n\t" ^
+
+              label_cpyParams_inc ^":\n\t\t" ^         (* copying the params from env to extEnv[0] *)
+              "mov rdx, [rbp + (3+rcx) * WORD_SIZE]\n\t\t" ^
+              "mov [r8 + (rcx-1) * WORD_SIZE], rdx\n\t\t" ^
+              "loop "^ label_cpyParams_no_inc ^"\n\t" ^
+
+              label_AftercpyParams_no_inc ^":\n\t" ^
+              "\tmov [rax + 0 * WORD_SIZE], r8\n\t" ^      (* put pointer to extEnv[0] in dedicated address, rax now holds the pointer to full extEnv *)
+              "mov rbx, rax\n\t" ^                          (* rbx <- rax *)
+              "MAKE_CLOSURE(rax, rbx, "^ label_Lcode_inc ^")\n\t" ^
+              "jmp "^ label_Lcont_inc ^"\n\t" ^ 
+
+              (* Lcode for the closure *)
+              label_Lcode_no_inc ^":\n\t\t" ^
+              label_adjustStuck_inc ^":\n\t\t" ^
+              adjust_stack args last body ^           
+              "\t\tpush rbp\n\t\t" ^
+              "mov rbp, rsp\n\t\t" ^
+              gen consts fvars body (env_size+1) ^
+              "\t\tleave\n\t\t" ^
+              "ret\n\t" ^
+              label_Lcont_no_inc ^":\n"
+
+
+      | Applic'(proc, exps) ->
+        let label_procIsClosure_inc = make_unique_procIsClosure true in
+        let label_procIsClosure_no_inc = make_unique_procIsClosure false in
+                            ";; Applic'(proc, exps)\n" ^
+                            (List.fold_right (fun ex str -> str ^ 
+                                                          (gen consts fvars ex env_size) ^"\n" ^
+                                                          "push rax\n") exps "") ^
+                            "push "^ string_of_int (List.length exps) ^"\n\t" ^     (* pushing n *)
+                            (gen consts fvars proc env_size) ^
+                            (* Verify that rax has type closure *)
+                            "\tcmp byte [rax], T_CLOSURE\n\t" ^
+                            "je "^ label_procIsClosure_inc ^"\n\t" ^
+                            (* case rax doesn't have type closure *)
+                            (* handle exception============================ *)
+                            "mov rax, 0\n\t" ^
+                            "leave\n\t" ^
+                            "ret\n\t" ^
+                            (* case rax has type closure *)
+                            label_procIsClosure_no_inc ^ ":\n\t\t" ^
+                            (* pushing env *)
+                            "push qword [rax + TYPE_SIZE]\n\t\t" ^           
+                            (* calling code *)
+                            "call qword [rax + TYPE_SIZE + WORD_SIZE]\n\t\t" ^       (* jumping to proc_code section *)
+
+                            (* upon returning from proc 
+                             poping env, n, and the n arguments from the stack *)
+                            "add rsp , 8*1     ; pop env\n\t\t" ^
+                            "pop rbx           ; pop arg count\n\t\t" ^
+                            "shl rbx , 3       ; rbx = rbx * 8\n\t\t" ^
+                            "add rsp , rbx     ; pop args\n"   
+
+      | ApplicTP'(proc, exps) -> 
+        let label_procIsClosure_inc = make_unique_procIsClosure true in
+        let label_procIsClosure_no_inc = make_unique_procIsClosure false in
+
+        let label_replaceFramesTP_inc = make_unique_replaceFramesTP true in
+        let label_replaceFramesTP_no_inc = make_unique_replaceFramesTP false in
+
+
+                            ";; ApplicTP'(proc, exps)\n" ^
+                            (List.fold_right (fun ex str -> str ^ 
+                                                          (gen consts fvars ex env_size) ^"\n\t" ^
+                                                          "push rax\n\t") exps "\t") ^
+                            "\tpush "^ string_of_int (List.length exps) ^"\n\t" ^   (* pushing n *)
+                            (gen consts fvars proc env_size) ^
+
+                            (* Verify that rax has type closure *)
+                            "cmp byte [rax], T_CLOSURE\n\t" ^
+                            "je "^ label_procIsClosure_inc ^"\n\t" ^
+                            (* case rax doesn't have type closure *)
+                            (* handle exception============================ *)
+                            "mov rax, 0\n\t" ^
+                            "leave\n\t" ^
+                            "ret\n\t" ^
+                            
+
+
+                            (* case rax has type closure *)
+                            label_procIsClosure_no_inc ^ ":\n\t" ^
+                            (* pushing env *)
+                            "push qword [rax + TYPE_SIZE]\n\t" ^   
+                            "push qword [rbp + 8 * 1]       ; old ret addr\n\t" ^
+
+          (* fixing stack *)
+                            "mov rcx, [rsp + 2 * WORD_SIZE]\n\t" ^        (* rcx <- m ( = number of new_args) *)
+                            "add rcx, 3\n\t" ^                            (* rcx <- newFrame size = m + 3 ( = m,env,ret) *)
+                            "mov rdx, [rbp + 3 * WORD_SIZE]\n\t" ^        (* rdx <- n ( = number of old_args) *)
+                            "add rdx, 4\n\t" ^                            (* rdx <- oldFrame size = n + 4 ( = n,env,ret,rbp) *)
+                            "mov r8, rdx\n\t" ^                           (* r8  <- oldFrame size (saved for a future purpose) *)
+                            "mov r9, [rbp]\n\t" ^                         (* r9  <- old_rbp (saved for a future purpose) *)
+
+                            (* replacing oldFrame with newFrame *)
+                            label_replaceFramesTP_inc ^ ":\n\t\t" ^
+                            (* r10 will hold new_arg's place -> rsp + (rcx-1) * WORD_SIZE   *)           
+                            "mov r10, rcx\n\t\t" ^                            (* r10 <- (rcx) *)
+                            "dec r10\n\t\t" ^                                 (* r10 <- (rcx-1) *)
+                            "shl r10, 3\n\t\t" ^                              (* r10 <- (rcx-1) * WORD_SIZE   *)
+                            "add r10, rsp\n\t\t" ^                            (* r10 <- rsp + (rcx-1) * WORD_SIZE   *)
+                            "mov rbx, [r10]\n\t\t" ^                          (* rbx <- new_arg *)
+
+                            (* r10 will hold old_arg's place -> rbp + (rdx-1) * WORD_SIZE   *)           
+                            "mov r10, rdx\n\t\t" ^                            (* r10 <- (rdx) *)
+                            "dec r10\n\t\t" ^                                 (* r10 <- (rdx-1) *)
+                            "shl r10, 3\n\t\t" ^                              (* r10 <- (rdx-1) * WORD_SIZE   *)
+                            "add r10, rbp\n\t\t" ^                            (* r10 <- rbp + (rdx-1) * WORD_SIZE   *)
+                            "mov [r10], rbx\n\t\t" ^                          (* put rbx in old_arg's place *)
+
+                            "dec rdx\n\t\t" ^
+                            "loop "^ label_replaceFramesTP_no_inc ^"\n\t" ^
+
+                            (* change the rsp according to the number of cells deleted *)
+                            "shl r8, 3\n\t" ^
+                            "add rsp, r8\n\t" ^
+                            (* change the rbp to point to the frame before the TP_frame  *)
+                            "mov rbp, r9\n\t" ^
+          (* finish fixing stack *)
+                            (* jumping to the code (instead of call) *)
+                            "jmp [rax + TYPE_SIZE + WORD_SIZE]\n\t"      (* jump to proc_code section *)
+
+      | _-> raise X_this_should_not_happen
+  ;;
+
+  let generate consts fvars e = gen consts fvars e 0 ;;
+
+
+  (*  *)
+(* let test_from_read s =  List.map Semantics.run_semantics (Tag_Parser.tag_parse_expressions (Reader.read_sexprs s));;
+let test_make_consts_tbl s = (Code_Gen.make_consts_tbl (test_from_read s));;
+let test_make_fvars_tbl s = (Code_Gen.make_fvars_tbl (test_from_read s));;
+let test_generate s = List.map (Code_Gen.generate (test_make_consts_tbl s) (test_make_fvars_tbl s)) (test_from_read s);; *)
+(*  *)
 end;;
 
diff --git a/compiler.ml b/compiler.ml
index fbf0ad5..38b90a8 100644
--- a/compiler.ml
+++ b/compiler.ml
@@ -35,13 +35,14 @@ let make_prologue consts_tbl fvars_tbl =
     (* Additional rational numebr ops *)
     "numerator", "numerator"; "denominator", "denominator"; "gcd", "gcd";
     (* you can add yours here *)
+    "car", "car"; "cdr", "cdr"; "cons", "cons"; "set-car!", "set_car"; "set-cdr!", "set_cdr"; "apply", "apply"
   ] in
   let make_primitive_closure (prim, label) =
     (* This implementation assumes fvars are addressed by an offset from the label `fvar_tbl`.
        If you use a different addressing scheme (e.g., a label for each fvar), change the 
        addressing here to match. *)
     "MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")\n" ^
-      "mov [fvar_tbl+" ^  (string_of_int (List.assoc prim fvars_tbl)) ^ "], rax" in
+      "mov [fvar_tbl+" ^  (string_of_int (List.assoc prim fvars_tbl)) ^ " * WORD_SIZE], rax" in
   let constant_bytes (c, (a, s)) =
     (* Adapt the deconstruction here to your constants data generation scheme.
        This implementation assumes the bytes representing the constants are pre-computed in
@@ -132,6 +133,8 @@ try
 
   (* load the input file and stdlib *)
   let code =  (file_to_string "stdlib.scm") ^ (file_to_string infile) in
+  (* let code =   (file_to_string infile) in *)
+
 
   (* generate asts for all the code *)
   let asts = string_to_asts code in
@@ -146,7 +149,7 @@ try
   let generate = Code_Gen.generate consts_tbl fvars_tbl in 
   let code_fragment = String.concat "\n\n"
                         (List.map
-                           (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void")
+                           (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void\n")
                            asts) in
 
   (* merge everything into a single large string and print it out *)
diff --git a/compiler.s b/compiler.s
index fb7d307..b6de285 100644
--- a/compiler.s
+++ b/compiler.s
@@ -123,11 +123,26 @@
         dq %3
 %endmacro
 
+;;added
+%macro MAKE_LITERAL 2 ; Make a literal of type %1
+					  ; followed by the definition %2
+		db %1
+		%2
+%endmacro
+
+%define TYPE_SIZE 1
+%define WORD_SIZE 8
+
 %define MAKE_RATIONAL(r, num, den) \
 	MAKE_TWO_WORDS r, T_RATIONAL, num, den
 
 %define MAKE_LITERAL_RATIONAL(num, den) \
 	MAKE_WORDS_LIT T_RATIONAL, num, den
+
+%define MAKE_LITERAL_CHAR(val) MAKE_LITERAL T_CHAR, db val 		;;added
+%define MAKE_LITERAL_FLOAT(val) MAKE_LITERAL T_FLOAT, dq val	;;added
+%define MAKE_LITERAL_SYMBOL(val) MAKE_LITERAL T_SYMBOL, dq val	;;added
+
 	
 %define MAKE_PAIR(r, car, cdr) \
         MAKE_TWO_WORDS r, T_PAIR, car, cdr
@@ -661,3 +676,5 @@ write_sob_if_not_void:
 section .data
 .newline:
 	db CHAR_NEWLINE, 0
+
+
diff --git a/prims.ml b/prims.ml
index 89ee1ab..f899e06 100644
--- a/prims.ml
+++ b/prims.ml
@@ -10,7 +10,7 @@
    However, adding correctness-checking and error handling *as general templates* would be
    rather simple.
  *)
-module type PRIMS = sig
+ module type PRIMS = sig
   val procs : string;;
 end
 
@@ -353,5 +353,220 @@ module Prims : PRIMS = struct
   (* This is the interface of the module. It constructs a large x86 64-bit string using the routines
      defined above. The main compiler pipline code (in compiler.ml) calls into this module to get the
      string of primitive procedures. *)
-  let procs = String.concat "\n\n" [type_queries ; numeric_ops; misc_ops];;
+  let procs = String.concat "\n\n" [type_queries ; numeric_ops; misc_ops] ^
+
+            ";;;;;;;; added prim functions\n" ^ 
+
+            "car:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+              "mov rbx, PVAR(0)  ;; PVAR(0) = args[0] (this time a pair)\n\t" ^
+              "CAR rax, rbx\n\t" ^
+              "leave\n\t" ^
+              "ret\n" ^
+
+            "cdr:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+              "mov rbx, PVAR(0)  ;; PVAR(0) = args[0] (this time a pair)\n\t" ^
+              "CDR rax, rbx\n\t" ^
+              "leave\n\t" ^
+              "ret\n" ^
+
+            "cons:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+              "mov rbx, PVAR(0)              ;; PVAR(0) = args[0] (this time an object)\n\t" ^
+              "mov rcx, PVAR(1)              ;; PVAR(1) = args[1] (this time an object)\n\t" ^
+              "MAKE_PAIR(rax, rbx, rcx)\n\t" ^
+              "leave\n\t" ^
+              "ret\n" ^
+
+            "set_car:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+              "mov rbx, PVAR(0)              ;; rbx <- args[0] (this time a pair)\n\t" ^
+              "mov rcx, PVAR(1)              ;; rcx <- = args[1] (this time an object)\n\t" ^
+              "mov [rbx + TYPE_SIZE], rcx\n\t" ^
+              "mov rax, SOB_VOID_ADDRESS\n\t" ^
+              "leave\n\t" ^
+              "ret\n" ^
+
+            "set_cdr:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+              "mov rbx, PVAR(0)              ;; rbx <- args[0] (this time a pair)\n\t" ^
+              "mov rcx, PVAR(1)              ;; rcx <- = args[1] (this time an object)\n\t" ^
+              "mov [rbx + TYPE_SIZE + WORD_SIZE], rcx\n\t" ^
+              "mov rax, SOB_VOID_ADDRESS\n\t" ^
+              "leave\n\t" ^
+              "ret\n" ^
+
+            "list_length:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+              
+              "mov rax, 0\n\t" ^
+              (* "mov rbx, [rbx]      ;; rbx <- the list (because rbx first points to list)\n\t" ^ *)
+              "loop:\n\t" ^
+              "add rax, 1          ;; rax not empty (checked in apply)\n\t" ^
+              "CDR rbx, rbx       ;; rbx <- cdr list\n\t" ^
+              "cmp rbx, SOB_NIL_ADDRESS\n\t" ^
+              "jne loop\n\t" ^
+
+              "leave\n\t" ^
+              "ret\n" ^
+
+            "apply:\n\t" ^
+              "push rbp\n\t" ^
+              "mov rbp, rsp\n\t" ^
+
+              ";;; 0. save old rbp ( = [rbp]), ret, proc. get list.length\n\t" ^
+              (* ";;; 1. reverse list\n\t" ^
+              ";;; 2. pushing elements of rev_list to stack,\n\t" ^ *)
+              ";;; new 2. make space on stack and ''push'' list elements \n\t" ^
+              ";;; 3. push objects to stack,\n\t" ^
+              (* ";;; 4. replace all args with the old frame places\n\t" ^
+              ";;; 5. add rsp old_frame_size (n+4)\n\t" ^ *)
+              ";;; 6. push number of total args\n\t" ^
+              ";;; 7. check proc is closure, push env, push ret\n\t" ^
+              ";;; 8. call proc.code\n\t" ^
+              ";;; 9. clean stack frame (add rsp as in Applic)\n\t" ^
+              ";;; 10. rbp <- old rbp\n" ^
+
+            ";;; 0.\n\t" ^
+              "mov r9, [rbp + 3 * WORD_SIZE]                 ;; r9 <- number of args ( = n)\n\t" ^
+              "mov r8, r9                        ;; r8 <- number of args\n\t" ^
+              "sub r9, 2                         ;; r9 <- number of objects\n\t" ^
+              "mov rbx, PVAR(r9 + 1)             ;; rbx <- pointer to list (arg[n-1])\n\t" ^
+              "mov r11, [rbp]                     ;; r11 <- old rbp\n\t" ^
+              "mov r12, [rbp + 1 * WORD_SIZE]     ;; r12 <- ret address\n\t" ^
+              "mov r13, PVAR(0)                   ;; r13 <- proc\n\t" ^
+
+              "cmp rbx, SOB_NIL_ADDRESS\n\t" ^
+              "je empty_list\n\t" ^
+              "push rbx\n\t" ^
+              "call list_length\n\t" ^
+              "pop rbx\n\t" ^
+              "mov r10, rax                       ;; r10 <- number of elements in list \n\t" ^
+              "jmp after_length \n\t" ^
+              "empty_list:\n\t" ^
+              "mov r10, 0                         ;; r10 <- number of elements in list (case list is empty)\n" ^
+              "after_length:\n" ^
+            ";;; end 0.\n" ^
+              
+            (* ";;; 1.\n\t" ^
+              "mov rcx, r10                   ;; rcx <- list.length\n\t" ^
+              "cmp rcx, 0\n\t" ^
+              "je after_reverse_list\n\t" ^
+
+
+              "mov rdx, SOB_NIL_ADDRESS      ;; rdx <- first cdr \n\t" ^
+              "reverse_list:\n\t" ^
+              "CAR rax, rbx                 ;; rax <- car list\n\t" ^
+              "MAKE_PAIR(rdx, rax, rdx)     ;; rdx <- will eventually hold rev_list\n\t" ^
+              "CDR rbx, rbx                 ;; rbx <- cdr list\n\t" ^
+              "loop reverse_list\n\t" ^
+
+
+              "after_reverse_list:\n" ^
+            ";;; end 1.\n" ^ *)
+
+
+            ";;; 2.\n\t" ^
+              "mov rcx, r10                   ;; rcx <- list.length\n\t" ^
+              "shl r10, 3                     ;; r10 <- list.length * WORD_SIZE \n\t" ^
+              "sub rsp, r10                   ;; make place on stack to list elements \n\t" ^
+              "mov r10, 0                     ;; r10 <- 0 to (rcx -1)\n\t" ^
+              
+              "cmp rcx, 0\n\t" ^
+              "je after_push_elements\n\t" ^
+              "push_elements_of_list:\n\t" ^
+              "CAR rax, rbx                   ;; rax <- car list\n\t" ^
+              "                               ;; rdx <- rsp + r10 * WORD_SIZE\n\t" ^
+              "mov rdx, r10                   ;; rdx <- r10\n\t" ^
+              "shl rdx, 3                     ;; rdx <- r10 * WORD_SIZE\n\t" ^
+              "add rdx, rsp                   ;; rdx <- rsp + r10 * WORD_SIZE\n\t" ^
+              "mov [rdx], rax                 ;; ''pushing'' list elements \n\t" ^
+              "CDR rbx, rbx                   ;; rbx <- cdr list\n\t" ^
+              "add r10, 1\n\t" ^
+              "loop push_elements_of_list\n\t" ^
+              "after_push_elements:\n" ^
+            ";;; end 2.\n" ^
+
+            (* ";;; 2.\n\t" ^
+              "mov rcx, r10                   ;; rcx <- list.length\n\t" ^
+              "cmp rcx, 0\n\t" ^
+              "je after_push_elements\n\t" ^
+              "push_elements_of_list:\n\t" ^
+              "CAR rbx, rdx                  ;; rbx <- car list\n\t" ^
+              "push rbx\n\t" ^
+              "CDR rdx, rdx                  ;; rdx <- cdr list\n\t" ^
+              "loop push_elements_of_list\n\t" ^
+              "after_push_elements:\n" ^
+            ";;; end 2.\n" ^ *)
+
+            ";;; 3.\n\t" ^
+              "mov rcx, r9                   ;; rcx <- number of objects\n\t" ^
+              "cmp rcx, 0\n\t" ^
+              "je after_push_objects\n\t" ^
+              "push_objectst:\n\t" ^
+              "push PVAR(rcx)                ;; (arg1,...argn-2) ((no arg0(=proc) and no argn-1(=list) ))\n\t" ^
+              "loop push_objectst\n\t" ^
+              "after_push_objects:\n" ^
+            ";;; end 3.\n" ^
+
+            (* ";;; 4.\n\t" ^
+              "mov rcx, r9                   ;; rcx <- number of objects\n\t" ^
+              "add rcx, r10                   ;; rcx <- number of objects + list.length\n\t" ^
+              "cmp rcx, 0\n\t" ^
+              "je after_shift\n\t" ^
+              "shift_args:\n\t" ^
+              "mov rdx, [rsp + (rcx-1) * WORD_SIZE]\n\t" ^
+              "mov [rbp + (r8+3) * WORD_SIZE], rdx \n\t" ^
+              "sub r8, 1\n\t" ^
+              "loop shift_args\n\t" ^
+              "after_shift:\n" ^
+            ";;; end 4.\n" ^
+
+            ";;; 5.\n\t" ^
+              "mov r8, r9                    ;; r8 <- number of objects   number of args + n,env,ret,old_rbp\n\t" ^
+              "add r8, 2 + 4                 ;; r8 <- n+4 = number of objects +2+4 = number of args + n,env,ret,old_rbp\n\t" ^
+              "shl r8, 3                     ;; r8 <- multiply r8 by WORD_SIZE\n\t" ^
+              "add rsp, r8                   ;; rsp now points to the new stack point\n" ^
+            ";;; end 5.\n" ^ *)
+            ";;; 6.\n\t" ^
+              "add r9, r10\n\t" ^
+              "push r9\n" ^
+            ";;; end 6.\n" ^
+            ";;; 7.\n\t" ^
+              "cmp byte [r13], T_CLOSURE      ;; r13 is proc, check this is a closure\n\t" ^  
+              "je proc_is_closure\n" ^
+            ";;; case proc doesn't have type closure\n" ^
+            ";;; handle exception\n\t" ^
+              "mov rax, 0\n\t" ^
+              "leave\n\t" ^
+              "ret\n\t" ^
+              "proc_is_closure:\n\t" ^
+              "CLOSURE_ENV rbx, r13\n\t" ^
+              "push rbx\n\t" ^
+              (* "push r12                       ;; r12 is ret address\n" ^ *)
+            ";;; end 7.\n" ^
+            ";;; 8.\n\t" ^
+              "CLOSURE_CODE rbx, r13\n\t" ^
+              "call rbx\n" ^
+            ";;; end 8.\n" ^
+            ";;; 9.\n\t" ^
+              "add rsp , 8*1     ; pop env\n\t" ^
+              "pop rbx           ; pop arg count\n\t" ^
+              "shl rbx , 3       ; rbx = rbx * 8\n\t" ^
+              "add rsp , rbx     ; pop args\n" ^
+            ";;; end 9.\n" ^
+            ";;; 10.\n\t" ^
+              "pop rbp                  ;; r11 <- old rbp\n" ^
+            ";;; end 10.\n\t" ^
+
+              "ret\n" ^
+
+            ";;;;;;;; finish added prim functions \n" ;;
 end;;
diff --git a/reader.ml b/reader.ml
index 32445c2..4a146a1 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,3 +1,195 @@
+(* 
+
+(* pc.ml
+ * A parsing-combinators package for ocaml
+ *
+ * Prorammer: Mayer Goldberg, 2018
+ *)
+
+(* general list-processing procedures *)
+
+let rec ormap f s =
+  match s with
+  | [] -> false
+  | car :: cdr -> (f car) || (ormap f cdr);;
+
+let rec andmap f s =
+  match s with
+  | [] -> true
+  | car :: cdr -> (f car) && (andmap f cdr);;	  
+
+let lowercase_ascii  =
+  let delta = int_of_char 'A' - int_of_char 'a' in
+  fun ch ->
+  if ('A' <= ch && ch <= 'Z')
+  then char_of_int ((int_of_char ch) - delta)
+  else ch;;
+
+let string_to_list str =
+  let rec loop i limit =
+    if i = limit then []
+    else (String.get str i) :: (loop (i + 1) limit)
+  in
+  loop 0 (String.length str);;
+
+let list_to_string s =
+  String.concat "" (List.map (fun ch -> String.make 1 ch) s);;
+
+module PC = struct
+
+(* the parsing combinators defined here *)
+  
+exception X_not_yet_implemented;;
+
+exception X_no_match;;
+
+let const pred =
+  function 
+  | [] -> raise X_no_match
+  | e :: s ->
+     if (pred e) then (e, s)
+     else raise X_no_match;;
+
+let caten nt1 nt2 s =
+  let (e1, s) = (nt1 s) in
+  let (e2, s) = (nt2 s) in
+  ((e1, e2), s);;
+
+let pack nt f s =
+  let (e, s) = (nt s) in
+  ((f e), s);;
+
+let nt_epsilon s = ([], s);;
+
+let caten_list nts =
+  List.fold_right
+    (fun nt1 nt2 ->
+     pack (caten nt1 nt2)
+	  (fun (e, es) -> (e :: es)))
+    nts
+    nt_epsilon;;
+
+let disj nt1 nt2 =
+  fun s ->
+  try (nt1 s)
+  with X_no_match -> (nt2 s);;
+
+let nt_none _ = raise X_no_match;;
+  
+let disj_list nts = List.fold_right disj nts nt_none;;
+
+let delayed thunk s =
+  thunk() s;;
+
+let nt_end_of_input = function
+  | []  -> ([], [])
+  | _ -> raise X_no_match;;
+
+let rec star nt s =
+  try let (e, s) = (nt s) in
+      let (es, s) = (star nt s) in
+      (e :: es, s)
+  with X_no_match -> ([], s);;
+
+let plus nt =
+  pack (caten nt (star nt))
+       (fun (e, es) -> (e :: es));;
+
+let guard nt pred s =
+  let ((e, _) as result) = (nt s) in
+  if (pred e) then result
+  else raise X_no_match;;
+  
+let diff nt1 nt2 s =
+  match (let result = nt1 s in
+	 try let _ = nt2 s in
+	     None
+	 with X_no_match -> Some(result)) with
+  | None -> raise X_no_match
+  | Some(result) -> result;;
+
+let not_followed_by nt1 nt2 s =
+  match (let ((_, s) as result) = (nt1 s) in
+	 try let _ = (nt2 s) in
+	     None
+	 with X_no_match -> (Some(result))) with
+  | None -> raise X_no_match
+  | Some(result) -> result;;
+	  
+let maybe nt s =
+  try let (e, s) = (nt s) in
+      (Some(e), s)
+  with X_no_match -> (None, s);;
+
+(* useful general parsers for working with text *)
+
+let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
+
+let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
+
+let char_ci =
+  make_char (fun ch1 ch2 ->
+	     (lowercase_ascii ch1) =
+	       (lowercase_ascii ch2));;
+
+let make_word char str = 
+  List.fold_right
+    (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
+    (List.map char (string_to_list str))
+    nt_epsilon;;
+
+let word = make_word char;;
+
+let word_ci = make_word char_ci;;
+
+let make_one_of char str =
+  List.fold_right
+    disj
+    (List.map char (string_to_list str))
+    nt_none;;
+
+let one_of = make_one_of char;;
+
+let one_of_ci = make_one_of char_ci;;
+
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+
+let make_range leq ch1 ch2 (s : char list) =
+  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
+
+let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
+
+let range_ci =
+  make_range (fun ch1 ch2 ->
+	      (lowercase_ascii ch1) <=
+		(lowercase_ascii ch2));;
+
+let nt_any (s : char list) = const (fun ch -> true) s;;
+
+let trace_pc desc nt s =
+  try let ((e, s') as args) = (nt s)
+      in
+      (Printf.printf ";;; %s matched the head of \"%s\", and the remaining string is \"%s\"\n"
+		     desc
+		     (list_to_string s)
+		     (list_to_string s') ;
+       args)
+  with X_no_match ->
+    (Printf.printf ";;; %s failed on \"%s\"\n"
+		   desc
+		   (list_to_string s) ;
+     raise X_no_match);;
+
+(* testing the parsers *)
+
+let test_string nt str =
+  let (e, s) = (nt (string_to_list str)) in
+  (e, (Printf.sprintf "->[%s]" (list_to_string s)));;
+
+end;; (* end of struct PC *)
+
+end-of-input *)
+
 
 #use "pc.ml";;
 
@@ -27,8 +219,8 @@ let rec sexpr_eq s1 s2 =
   | String(s1), String(s2) -> s1 = s2
   | Symbol(s1), Symbol(s2) -> s1 = s2
   | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
-  | _ -> false;;
-
+  |  _-> false;;
+  
 module Reader: sig
   val read_sexprs : string -> sexpr list
 end
@@ -41,6 +233,212 @@ let normalize_scheme_symbol str =
   else Printf.sprintf "|%s|" str;;
 
 
-let read_sexprs string = raise X_not_yet_implemented;;
+let nt_Bool =
+  let bool = PC.caten (PC.char '#') (PC.one_of_ci "tf") in
+  PC.pack bool (fun (a,b) -> 
+    match b with
+    | 't' | 'T' -> Bool (true)
+    | 'f' | 'F' -> Bool (false)
+    | _-> raise PC.X_no_match);;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_Char =
+    let nt_CharPrefix =  PC.pack (PC.word "#\\") (fun _-> Nil) in
+    let nt_VisibleSimpleChar = PC.pack (PC.const (fun ch-> (int_of_char ch) > 32)) (fun ch-> Char(ch)) in
+    let nt_NamedChar =  PC.disj_list[PC.pack (PC.word_ci "newline") (fun _-> Char(char_of_int 10));
+                                     PC.pack (PC.word_ci "nul") (fun _-> Char(char_of_int 0));
+                                     PC.pack (PC.word_ci "page") (fun _-> Char(char_of_int 12));
+                                     PC.pack (PC.word_ci "return") (fun _-> Char(char_of_int 13));
+                                     PC.pack (PC.word_ci "space") (fun _-> Char(char_of_int 32));
+                                     PC.pack (PC.word_ci "tab") (fun _-> Char(char_of_int 9));] in
+    PC.pack (PC.caten nt_CharPrefix (PC.disj nt_NamedChar nt_VisibleSimpleChar))
+            (fun (prefix,ch)-> ch);;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let rec gcd a b =
+      if a = b then a
+      else if a > b then gcd (a - b) b
+      else gcd a (b - a);;
+
+let char_to_digit c = (int_of_char c) - (int_of_char '0');;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_Number = 
+    let nt_digits = PC.plus (PC.range '0' '9') in
+    let nt_Natural = PC.pack nt_digits
+                             list_to_string in
+    (* let nt_Natural = PC.pack nt_digits 
+                             (fun digits-> (List.fold_left
+                              (fun x y -> 10 * x + (char_to_digit y)) 0 digits)) in    *)
+    let nt_MinusInteger = 
+      PC.pack (PC.caten(PC.char '-') nt_Natural)
+              (fun (_, num)-> "-" ^ num ) in
+    let nt_PlusInteger = 
+      PC.pack (PC.caten(PC.char '+') nt_Natural)
+              (fun (_, num)->  num ) in
+
+    let nt_Integer = PC.disj_list[nt_MinusInteger; nt_PlusInteger; nt_Natural] in
+    let nt_IntegerPacked = PC.pack nt_Integer (fun str-> Number(Fraction(int_of_string str, 1))) in
+
+    let nt_Fraction = 
+      PC.pack (PC.caten_list[nt_Integer; PC.pack (PC.char '/') (fun ch-> "/"); nt_Natural]) 
+              (fun list-> match list with
+                [num; _; denom] ->
+                    let num = int_of_string num in
+                    let numForGcd =  if num < 0 then -1*num else num in
+                    let denom = int_of_string denom in
+                    let denomForGcd =  if denom < 0 then -1*denom else denom in
+                    let gcd1 = gcd numForGcd denomForGcd in
+                    Number(Fraction(num/gcd1, denom/gcd1))
+                | _-> raise PC.X_no_match) in
+     
+    let nt_FloatNotPacked = (PC.caten_list[nt_Integer; PC.pack (PC.char '.') (fun ch-> "."); nt_Natural]) in
+    let nt_FloatString = PC.pack nt_FloatNotPacked
+                                 (fun list-> match list with
+                                  | [int; _; natural]->  int ^ "." ^ natural 
+                                  | _-> raise PC.X_no_match) in 
+    let nt_Float = PC.pack nt_FloatNotPacked
+                             (fun list-> match list with
+                             | [befDot; dot; aftDot] -> Number(Float(float_of_string (befDot ^ dot ^ aftDot)))
+                             | _-> raise PC.X_no_match) in
+
+    let nt_ScientificNotation = 
+      PC.pack (PC.caten_list[PC.disj nt_FloatString nt_Integer; PC.pack (PC.char_ci 'e') (fun _-> "e"); nt_Integer])
+              (fun list-> match list with
+              | [befE; e; aftE]-> Number(Float(float_of_string (befE ^ e ^ aftE)))
+              | _-> raise PC.X_no_match) in
+            
+    let nt_SymbolChar = PC.pack (PC.disj_list[ PC.range '0' '9'; PC.range_ci 'a' 'z'; PC.one_of ".!$^*-_=+<>?/:"])
+                                (fun sym-> 'a') in
+
+
+    PC.not_followed_by (PC.disj_list [nt_ScientificNotation; nt_Fraction; nt_Float; nt_IntegerPacked]) nt_SymbolChar ;;
+    (* PC.pack (PC.caten (PC.disj_list [nt_ScientificNotation; nt_Fraction; nt_Float; nt_IntegerPacked]) 
+                      (PC.disj nt_SymbolChar (PC.pack (PC.nt_whitespace) (fun _->'b')))) (* עבור הערות sexpr nt_Whitespace  לייבא את  *)
+            (fun (number, sym) -> if sym != 'a' then number else raise PC.X_no_match) ;; *)
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_String =
+  let nt_StringLiteralChar = PC.const (fun ch -> ch != '\"' && ch != '\\') in
+  let nt_StringMetaChar = PC.pack (PC.caten (PC.char '\\') (PC.one_of("\\\"tfnr"))) 
+                                  (fun (backslash, metaCh)-> match metaCh with
+                                  | 't' -> (char_of_int 9) | 'f' -> (char_of_int 12) | 'n' -> (char_of_int 10) | 'r' -> (char_of_int 13)
+                                  | char -> char) in 
+
+  let nt_StringChar = PC.disj nt_StringLiteralChar nt_StringMetaChar in
   
-end;; (* struct Reader *)
+  PC.pack (PC.caten(PC.caten (PC.char '\"') (PC.star nt_StringChar)) (PC.char '\"'))
+          (fun ((dquote1, str), dquote2)-> String(list_to_string str)) ;;
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_Symbol =
+  let nt_SymbolChar = PC.disj_list[ PC.range '0' '9'; PC.range_ci 'a' 'z'; PC.one_of ".!$^*-_=+<>?/:"] in
+  (* let nt_SymbolChar = PC.disj nt_SymbolCharNoDot (PC.char '.') in *)
+  let nt_SymbolCharPlus = PC.plus nt_SymbolChar in
+
+  PC.pack nt_SymbolCharPlus
+          (fun charList-> match charList with
+            | ['.'] -> raise PC.X_no_match
+            | chList -> Symbol(list_to_string (List.map (fun upper-> Char.lowercase_ascii upper) chList)));;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let rec nt_List s =
+
+  let nt_EmptyList = PC.pack (PC.caten_list[PC.pack (PC.char '(') (fun _->Nil); nt_Whitespaces; PC.pack (PC.char ')') (fun _->Nil)])
+                             (fun _-> Nil) in
+
+  (* PC.pack (PC.caten_list[PC.char '('; PC.delayed nt_SexprStar; PC.char ')'])  *)
+  let nt_RegularList =
+   PC.pack (PC.caten(PC.caten (PC.char '(') nt_SexprPlus) (PC.char ')'))
+          (fun ((l, exps), r) -> List.fold_right (fun a b -> Pair(a,b)) exps Nil ) in
+          
+ let nt_DottedList = 
+  PC.pack (PC.caten_list[PC.pack (PC.char '(') (fun _->[Nil]); nt_SexprPlus; PC.pack (PC.char '.') (fun _->[Nil]); PC.pack nt_Sexpr (fun exp->[exp] ); PC.pack (PC.char ')') (fun _->[Nil])]) 
+          (fun list-> match list with
+          | [l; exps; dot; [exp]; r] -> List.fold_right (fun a b -> Pair(a,b)) exps exp
+          | _-> raise PC.X_no_match) in
+    
+  PC.disj_list[nt_EmptyList; nt_RegularList; nt_DottedList]  s
+                            (*    ⟨List⟩ ::= ( ⟨Sexpr⟩* )
+                            ⟨DottedList⟩ ::= ( ⟨Sexpr⟩+ . ⟨Sexpr⟩ )   *)
+          (* ⟨List⟩ (a b c d) --> Pair(a, Pair(b, Pair(c, Pair(d,Nil))))
+      ⟨DottedList⟩ (a b c . d) --> Pair(a, Pair(b, Pair(c, d))) *)
+
+(* read_sexprs("'(a #;1 . a)") *)
+
+and nt_Sexpr s =
+               PC.pack (PC.caten_list[nt_Whitespaces;
+                                      PC.disj_list [nt_Bool; nt_Char; nt_String; nt_Number; nt_Symbol; nt_List;
+                                            nt_Quoted; nt_QuasiQuoted; nt_Unquoted; nt_UnquoteAndSpliced] ; 
+                                      nt_Whitespaces]) 
+                       (fun list-> match list with 
+                       | [_; exp; _]-> exp 
+                       | _-> raise PC.X_no_match) s  
+           
+
+and nt_SexprPlus s = (PC.plus nt_Sexpr) s
+and nt_SexprStar s = (PC.star nt_Sexpr) s
+                               
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+and nt_Quoted s = PC.pack (PC.caten_list[PC.pack (PC.char '\'') (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("quote"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s 
+
+and nt_QuasiQuoted s = PC.pack (PC.caten_list[PC.pack (PC.char '`') (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("quasiquote"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s
+
+and nt_Unquoted s = PC.pack (PC.caten_list[PC.pack (PC.char ',') (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("unquote"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s
+
+and nt_UnquoteAndSpliced s = PC.pack (PC.caten_list[PC.pack (PC.word ",@") (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("unquote-splicing"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s
+
+
+                             (* Pair(Symbol(name), Pair(sexpr, Nil())  *)
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+
+and nt_LineComment s = 
+    let nt_notNewLine = PC.star (PC.const (fun ch-> (int_of_char ch) != 10 && (int_of_char ch) != 3)) in (* 3 is end of input, 10 is a new line*)
+    PC.pack (PC.caten_list[PC.pack (PC.char ';') (fun _-> ' ');
+                           PC.pack nt_notNewLine (fun _-> ' ');
+                           PC.pack (PC.disj (PC.char (char_of_int 10)) (PC.char (char_of_int 3))) (fun _-> ' ')])
+            (fun comment-> ' ') s
+  (* ;dhbdhfj djfhd until \n *)
+    
+and nt_SexprComments s =
+    PC.pack (PC.caten_list[PC.pack (PC.word "#;") (fun _-> ' ');
+                           PC.pack (PC.star (PC.nt_whitespace)) (fun spaces-> ' ');
+                           PC.pack nt_Sexpr (fun _-> ' ')])
+            (fun  list-> match list with
+            | [_; _; _] -> ' '
+            | _-> raise PC.X_no_match) s
+
+and nt_Whitespaces s =   PC.pack (PC.star (PC.disj_list[nt_LineComment; nt_SexprComments; PC.nt_whitespace]))
+                                 (fun _-> Nil) s ;;
+(* and nt_Whitespaces s =  PC.pack (PC.star (PC.disj_list[nt_LineComment; nt_SexprComments; PC.pack (PC.star (PC.nt_whitespace)) (fun spaces-> Nil)]))
+(fun _-> Nil) s ;;  causes stack overflow  *)
+(* and nt_WSPlus s = PC.plus nt_Whitespaces s ;; *)
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let read_sexprs string = 
+  let parsed = nt_SexprStar (string_to_list string) in
+  match parsed with
+  | (p, _) -> p ;;
+     
+ end;; (* struct Reader *)
\ No newline at end of file
diff --git a/readme.txt b/readme.txt
index e69de29..a9b6f91 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,6 @@
+
+Assaf Moreno 311318240
+yadin benyamin 206819526
+
+
+(We) assert that the work we submitted is 100% our own. We have not received anypart from any other student in the class, nor have we give parts of it for use to others.Nor have we used code from other sources: Courses taught previously at this university,courses taught at other universities, various bits of code found on the Internet, etc.We realize that should our code be found to contain code from other sources, that aformal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinaryaction.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..55c1a71 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,3 +1,806 @@
+(* 
+
+
+
+(* pc.ml
+ * A parsing-combinators package for ocaml
+ *
+ * Prorammer: Mayer Goldberg, 2018
+ *)
+
+(* general list-processing procedures *)
+
+let rec ormap f s =
+  match s with
+  | [] -> false
+  | car :: cdr -> (f car) || (ormap f cdr);;
+
+let rec andmap f s =
+  match s with
+  | [] -> true
+  | car :: cdr -> (f car) && (andmap f cdr);;	  
+
+let lowercase_ascii  =
+  let delta = int_of_char 'A' - int_of_char 'a' in
+  fun ch ->
+  if ('A' <= ch && ch <= 'Z')
+  then char_of_int ((int_of_char ch) - delta)
+  else ch;;
+
+let string_to_list str =
+  let rec loop i limit =
+    if i = limit then []
+    else (String.get str i) :: (loop (i + 1) limit)
+  in
+  loop 0 (String.length str);;
+
+let list_to_string s =
+  String.concat "" (List.map (fun ch -> String.make 1 ch) s);;
+
+module PC = struct
+
+(* the parsing combinators defined here *)
+  
+exception X_not_yet_implemented;;
+
+exception X_no_match;;
+
+let const pred =
+  function 
+  | [] -> raise X_no_match
+  | e :: s ->
+     if (pred e) then (e, s)
+     else raise X_no_match;;
+
+let caten nt1 nt2 s =
+  let (e1, s) = (nt1 s) in
+  let (e2, s) = (nt2 s) in
+  ((e1, e2), s);;
+
+let pack nt f s =
+  let (e, s) = (nt s) in
+  ((f e), s);;
+
+let nt_epsilon s = ([], s);;
+
+let caten_list nts =
+  List.fold_right
+    (fun nt1 nt2 ->
+     pack (caten nt1 nt2)
+	  (fun (e, es) -> (e :: es)))
+    nts
+    nt_epsilon;;
+
+let disj nt1 nt2 =
+  fun s ->
+  try (nt1 s)
+  with X_no_match -> (nt2 s);;
+
+let nt_none _ = raise X_no_match;;
+  
+let disj_list nts = List.fold_right disj nts nt_none;;
+
+let delayed thunk s =
+  thunk() s;;
+
+let nt_end_of_input = function
+  | []  -> ([], [])
+  | _ -> raise X_no_match;;
+
+let rec star nt s =
+  try let (e, s) = (nt s) in
+      let (es, s) = (star nt s) in
+      (e :: es, s)
+  with X_no_match -> ([], s);;
+
+let plus nt =
+  pack (caten nt (star nt))
+       (fun (e, es) -> (e :: es));;
+
+let guard nt pred s =
+  let ((e, _) as result) = (nt s) in
+  if (pred e) then result
+  else raise X_no_match;;
+  
+let diff nt1 nt2 s =
+  match (let result = nt1 s in
+	 try let _ = nt2 s in
+	     None
+	 with X_no_match -> Some(result)) with
+  | None -> raise X_no_match
+  | Some(result) -> result;;
+
+let not_followed_by nt1 nt2 s =
+  match (let ((_, s) as result) = (nt1 s) in
+	 try let _ = (nt2 s) in
+	     None
+	 with X_no_match -> (Some(result))) with
+  | None -> raise X_no_match
+  | Some(result) -> result;;
+	  
+let maybe nt s =
+  try let (e, s) = (nt s) in
+      (Some(e), s)
+  with X_no_match -> (None, s);;
+
+(* useful general parsers for working with text *)
+
+let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
+
+let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
+
+let char_ci =
+  make_char (fun ch1 ch2 ->
+	     (lowercase_ascii ch1) =
+	       (lowercase_ascii ch2));;
+
+let make_word char str = 
+  List.fold_right
+    (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
+    (List.map char (string_to_list str))
+    nt_epsilon;;
+
+let word = make_word char;;
+
+let word_ci = make_word char_ci;;
+
+let make_one_of char str =
+  List.fold_right
+    disj
+    (List.map char (string_to_list str))
+    nt_none;;
+
+let one_of = make_one_of char;;
+
+let one_of_ci = make_one_of char_ci;;
+
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+
+let make_range leq ch1 ch2 (s : char list) =
+  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
+
+let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
+
+let range_ci =
+  make_range (fun ch1 ch2 ->
+	      (lowercase_ascii ch1) <=
+		(lowercase_ascii ch2));;
+
+let nt_any (s : char list) = const (fun ch -> true) s;;
+
+let trace_pc desc nt s =
+  try let ((e, s') as args) = (nt s)
+      in
+      (Printf.printf ";;; %s matched the head of \"%s\", and the remaining string is \"%s\"\n"
+		     desc
+		     (list_to_string s)
+		     (list_to_string s') ;
+       args)
+  with X_no_match ->
+    (Printf.printf ";;; %s failed on \"%s\"\n"
+		   desc
+		   (list_to_string s) ;
+     raise X_no_match);;
+
+(* testing the parsers *)
+
+let test_string nt str =
+  let (e, s) = (nt (string_to_list str)) in
+  (e, (Printf.sprintf "->[%s]" (list_to_string s)));;
+
+end;; (* end of struct PC *)
+
+(* end-of-input *)
+
+
+(* #use "pc.ml";; *)
+
+exception X_not_yet_implemented;;
+exception X_this_should_not_happen;;
+  
+type number =
+  | Fraction of int * int
+  | Float of float;;
+  
+type sexpr =
+  | Bool of bool
+  | Nil
+  | Number of number
+  | Char of char
+  | String of string
+  | Symbol of string
+  | Pair of sexpr * sexpr;;
+
+let rec sexpr_eq s1 s2 =
+  match s1, s2 with
+  | Bool(b1), Bool(b2) -> b1 = b2
+  | Nil, Nil -> true
+  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+  | Char(c1), Char(c2) -> c1 = c2
+  | String(s1), String(s2) -> s1 = s2
+  | Symbol(s1), Symbol(s2) -> s1 = s2
+  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+  |  _-> false;;
+  
+module Reader: sig
+  val read_sexprs : string -> sexpr list
+end
+= struct
+let normalize_scheme_symbol str =
+  let s = string_to_list str in
+  if (andmap
+	(fun ch -> (ch = (lowercase_ascii ch)))
+	s) then str
+  else Printf.sprintf "|%s|" str;;
+
+
+let nt_Bool =
+  let bool = PC.caten (PC.char '#') (PC.one_of_ci "tf") in
+  PC.pack bool (fun (a,b) -> 
+    match b with
+    | 't' | 'T' -> Bool (true)
+    | 'f' | 'F' -> Bool (false)
+    | _-> raise PC.X_no_match);;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_Char =
+    let nt_CharPrefix =  PC.pack (PC.word "#\\") (fun _-> Nil) in
+    let nt_VisibleSimpleChar = PC.pack (PC.const (fun ch-> (int_of_char ch) > 32)) (fun ch-> Char(ch)) in
+    let nt_NamedChar =  PC.disj_list[PC.pack (PC.word_ci "newline") (fun _-> Char(char_of_int 10));
+                                     PC.pack (PC.word_ci "nul") (fun _-> Char(char_of_int 0));
+                                     PC.pack (PC.word_ci "page") (fun _-> Char(char_of_int 12));
+                                     PC.pack (PC.word_ci "return") (fun _-> Char(char_of_int 13));
+                                     PC.pack (PC.word_ci "space") (fun _-> Char(char_of_int 32));
+                                     PC.pack (PC.word_ci "tab") (fun _-> Char(char_of_int 9));] in
+    PC.pack (PC.caten nt_CharPrefix (PC.disj nt_NamedChar nt_VisibleSimpleChar))
+            (fun (prefix,ch)-> ch);;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let rec gcd a b =
+      if a = b then a
+      else if a > b then gcd (a - b) b
+      else gcd a (b - a);;
+
+let char_to_digit c = (int_of_char c) - (int_of_char '0');;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_Number = 
+    let nt_digits = PC.plus (PC.range '0' '9') in
+    let nt_Natural = PC.pack nt_digits
+                             list_to_string in
+    (* let nt_Natural = PC.pack nt_digits 
+                             (fun digits-> (List.fold_left
+                              (fun x y -> 10 * x + (char_to_digit y)) 0 digits)) in    *)
+    let nt_MinusInteger = 
+      PC.pack (PC.caten(PC.char '-') nt_Natural)
+              (fun (_, num)-> "-" ^ num ) in
+    let nt_PlusInteger = 
+      PC.pack (PC.caten(PC.char '+') nt_Natural)
+              (fun (_, num)->  num ) in
+
+    let nt_Integer = PC.disj_list[nt_MinusInteger; nt_PlusInteger; nt_Natural] in
+    let nt_IntegerPacked = PC.pack nt_Integer (fun str-> Number(Fraction(int_of_string str, 1))) in
+
+    let nt_Fraction = 
+      PC.pack (PC.caten_list[nt_Integer; PC.pack (PC.char '/') (fun ch-> "/"); nt_Natural]) 
+              (fun list-> match list with
+                [num; _; denom] ->
+                    let num = int_of_string num in
+                    let numForGcd =  if num < 0 then -1*num else num in
+                    let denom = int_of_string denom in
+                    let denomForGcd =  if denom < 0 then -1*denom else denom in
+                    let gcd1 = gcd numForGcd denomForGcd in
+                    Number(Fraction(num/gcd1, denom/gcd1))
+                | _-> raise PC.X_no_match) in
+     
+    let nt_FloatNotPacked = (PC.caten_list[nt_Integer; PC.pack (PC.char '.') (fun ch-> "."); nt_Natural]) in
+    let nt_FloatString = PC.pack nt_FloatNotPacked
+                                 (fun list-> match list with
+                                  | [int; _; natural]->  int ^ "." ^ natural 
+                                  | _-> raise PC.X_no_match) in 
+    let nt_Float = PC.pack nt_FloatNotPacked
+                             (fun list-> match list with
+                             | [befDot; dot; aftDot] -> Number(Float(float_of_string (befDot ^ dot ^ aftDot)))
+                             | _-> raise PC.X_no_match) in
+
+    let nt_ScientificNotation = 
+      PC.pack (PC.caten_list[PC.disj nt_FloatString nt_Integer; PC.pack (PC.char_ci 'e') (fun _-> "e"); nt_Integer])
+              (fun list-> match list with
+              | [befE; e; aftE]-> Number(Float(float_of_string (befE ^ e ^ aftE)))
+              | _-> raise PC.X_no_match) in
+            
+    let nt_SymbolChar = PC.pack (PC.disj_list[ PC.range '0' '9'; PC.range_ci 'a' 'z'; PC.one_of ".!$^*-_=+<>?/:"])
+                                (fun sym-> 'a') in
+
+
+    PC.not_followed_by (PC.disj_list [nt_ScientificNotation; nt_Fraction; nt_Float; nt_IntegerPacked]) nt_SymbolChar ;;
+    (* PC.pack (PC.caten (PC.disj_list [nt_ScientificNotation; nt_Fraction; nt_Float; nt_IntegerPacked]) 
+                      (PC.disj nt_SymbolChar (PC.pack (PC.nt_whitespace) (fun _->'b')))) (* עבור הערות sexpr nt_Whitespace  לייבא את  *)
+            (fun (number, sym) -> if sym != 'a' then number else raise PC.X_no_match) ;; *)
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_String =
+  let nt_StringLiteralChar = PC.const (fun ch -> ch != '\"' && ch != '\\') in
+  let nt_StringMetaChar = PC.pack (PC.caten (PC.char '\\') (PC.one_of("\\\"tfnr"))) 
+                                  (fun (backslash, metaCh)-> match metaCh with
+                                  | 't' -> (char_of_int 9) | 'f' -> (char_of_int 12) | 'n' -> (char_of_int 10) | 'r' -> (char_of_int 13)
+                                  | char -> char) in 
+
+  let nt_StringChar = PC.disj nt_StringLiteralChar nt_StringMetaChar in
+  
+  PC.pack (PC.caten(PC.caten (PC.char '\"') (PC.star nt_StringChar)) (PC.char '\"'))
+          (fun ((dquote1, str), dquote2)-> String(list_to_string str)) ;;
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let nt_Symbol =
+  let nt_SymbolChar = PC.disj_list[ PC.range '0' '9'; PC.range_ci 'a' 'z'; PC.one_of ".!$^*-_=+<>?/:"] in
+  (* let nt_SymbolChar = PC.disj nt_SymbolCharNoDot (PC.char '.') in *)
+  let nt_SymbolCharPlus = PC.plus nt_SymbolChar in
+
+  PC.pack nt_SymbolCharPlus
+          (fun charList-> match charList with
+            | ['.'] -> raise PC.X_no_match
+            | chList -> Symbol(list_to_string (List.map (fun upper-> Char.lowercase_ascii upper) chList)));;
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let rec nt_List s =
+
+  let nt_EmptyList = PC.pack (PC.caten_list[PC.pack (PC.char '(') (fun _->Nil); nt_Whitespaces; PC.pack (PC.char ')') (fun _->Nil)])
+                             (fun _-> Nil) in
+
+  (* PC.pack (PC.caten_list[PC.char '('; PC.delayed nt_SexprStar; PC.char ')'])  *)
+  let nt_RegularList =
+   PC.pack (PC.caten(PC.caten (PC.char '(') nt_SexprPlus) (PC.char ')'))
+          (fun ((l, exps), r) -> List.fold_right (fun a b -> Pair(a,b)) exps Nil ) in
+          
+ let nt_DottedList = 
+  PC.pack (PC.caten_list[PC.pack (PC.char '(') (fun _->[Nil]); nt_SexprPlus; PC.pack (PC.char '.') (fun _->[Nil]); PC.pack nt_Sexpr (fun exp->[exp] ); PC.pack (PC.char ')') (fun _->[Nil])]) 
+          (fun list-> match list with
+          | [l; exps; dot; [exp]; r] -> List.fold_right (fun a b -> Pair(a,b)) exps exp
+          | _-> raise PC.X_no_match) in
+    
+  PC.disj_list[nt_EmptyList; nt_RegularList; nt_DottedList]  s
+                            (*    ⟨List⟩ ::= ( ⟨Sexpr⟩* )
+                            ⟨DottedList⟩ ::= ( ⟨Sexpr⟩+ . ⟨Sexpr⟩ )   *)
+          (* ⟨List⟩ (a b c d) --> Pair(a, Pair(b, Pair(c, Pair(d,Nil))))
+      ⟨DottedList⟩ (a b c . d) --> Pair(a, Pair(b, Pair(c, d))) *)
+
+(* read_sexprs("'(a #;1 . a)") *)
+
+and nt_Sexpr s =
+               PC.pack (PC.caten_list[nt_Whitespaces;
+                                      PC.disj_list [nt_Bool; nt_Char; nt_String; nt_Number; nt_Symbol; nt_List;
+                                            nt_Quoted; nt_QuasiQuoted; nt_Unquoted; nt_UnquoteAndSpliced] ; 
+                                      nt_Whitespaces]) 
+                       (fun list-> match list with 
+                       | [_; exp; _]-> exp 
+                       | _-> raise PC.X_no_match) s  
+           
+
+and nt_SexprPlus s = (PC.plus nt_Sexpr) s
+and nt_SexprStar s = (PC.star nt_Sexpr) s
+                               
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+and nt_Quoted s = PC.pack (PC.caten_list[PC.pack (PC.char '\'') (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("quote"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s 
+
+and nt_QuasiQuoted s = PC.pack (PC.caten_list[PC.pack (PC.char '`') (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("quasiquote"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s
+
+and nt_Unquoted s = PC.pack (PC.caten_list[PC.pack (PC.char ',') (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("unquote"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s
+
+and nt_UnquoteAndSpliced s = PC.pack (PC.caten_list[PC.pack (PC.word ",@") (fun _-> Nil); nt_Whitespaces; nt_Sexpr])
+                                  (fun list-> match list with 
+                                       |[q; _; exp] -> Pair(Symbol("unquote-splicing"), Pair(exp, Nil))
+                                       | _-> raise PC.X_no_match) s
+
+
+                             (* Pair(Symbol(name), Pair(sexpr, Nil())  *)
+
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+
+and nt_LineComment s = 
+    let nt_notNewLine = PC.star (PC.const (fun ch-> (int_of_char ch) != 10 && (int_of_char ch) != 3)) in (* 3 is end of input, 10 is a new line*)
+    PC.pack (PC.caten_list[PC.pack (PC.char ';') (fun _-> ' ');
+                           PC.pack nt_notNewLine (fun _-> ' ');
+                           PC.pack (PC.disj (PC.char (char_of_int 10)) (PC.char (char_of_int 3))) (fun _-> ' ')])
+            (fun comment-> ' ') s
+  (* ;dhbdhfj djfhd until \n *)
+    
+and nt_SexprComments s =
+    PC.pack (PC.caten_list[PC.pack (PC.word "#;") (fun _-> ' ');
+                           PC.pack (PC.star (PC.nt_whitespace)) (fun spaces-> ' ');
+                           PC.pack nt_Sexpr (fun _-> ' ')])
+            (fun  list-> match list with
+            | [_; _; _] -> ' '
+            | _-> raise PC.X_no_match) s
+
+and nt_Whitespaces s =   PC.pack (PC.star (PC.disj_list[nt_LineComment; nt_SexprComments; PC.nt_whitespace]))
+                                 (fun _-> Nil) s ;;
+(* and nt_Whitespaces s =  PC.pack (PC.star (PC.disj_list[nt_LineComment; nt_SexprComments; PC.pack (PC.star (PC.nt_whitespace)) (fun spaces-> Nil)]))
+(fun _-> Nil) s ;;  causes stack overflow  *)
+(* and nt_WSPlus s = PC.plus nt_Whitespaces s ;; *)
+(* --------------------------------------------------------------------------------------------------------------------------------- *)
+
+let read_sexprs string = 
+  let parsed = nt_SexprStar (string_to_list string) in
+  match parsed with
+  | (p, _) -> p ;;
+     
+ end;; (* struct Reader *)
+
+
+
+type constant =
+  | Sexpr of sexpr
+  | Void
+
+type expr =
+  | Const of constant
+  | Var of string
+  | If of expr * expr * expr
+  | Seq of expr list
+  | Set of expr * expr
+  | Def of expr * expr
+  | Or of expr list
+  | LambdaSimple of string list * expr
+  | LambdaOpt of string list * string * expr
+  | Applic of expr * (expr list);;
+
+let rec expr_eq e1 e2 =
+  match e1, e2 with
+  | Const Void, Const Void -> true
+  | Const(Sexpr s1), Const(Sexpr s2) -> sexpr_eq s1 s2
+  | Var(v1), Var(v2) -> String.equal v1 v2
+  | If(t1, th1, el1), If(t2, th2, el2) -> (expr_eq t1 t2) &&
+                                            (expr_eq th1 th2) &&
+                                              (expr_eq el1 el2)
+  | (Seq(l1), Seq(l2)
+    | Or(l1), Or(l2)) -> List.for_all2 expr_eq l1 l2
+  | (Set(var1, val1), Set(var2, val2)
+    | Def(var1, val1), Def(var2, val2)) -> (expr_eq var1 var2) &&
+                                             (expr_eq val1 val2)
+  | LambdaSimple(vars1, body1), LambdaSimple(vars2, body2) ->
+     (List.for_all2 String.equal vars1 vars2) &&
+       (expr_eq body1 body2)
+  | LambdaOpt(vars1, var1, body1), LambdaOpt(vars2, var2, body2) ->
+     (String.equal var1 var2) &&
+       (List.for_all2 String.equal vars1 vars2) &&
+         (expr_eq body1 body2)
+  | Applic(e1, args1), Applic(e2, args2) ->
+     (expr_eq e1 e2) &&
+       (List.for_all2 expr_eq args1 args2)
+  | _ -> false;;
+	
+                       
+exception X_syntax_error;;
+
+
+module type TAG_PARSER = sig
+  val tag_parse_expressions : sexpr list -> expr list
+end;; (* signature TAG_PARSER *)
+
+module Tag_Parser : TAG_PARSER = struct
+
+let reserved_word_list =
+  ["and"; "begin"; "cond"; "define"; "else";
+   "if"; "lambda"; "let"; "let*"; "letrec"; "or";
+   "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
+   "unquote-splicing"];;  
+
+(* work on the tag parser starts here *)
+
+(* ----------------------------------------------------------help functions-------------------------------------------------------- *)
+
+let rec lastElement list =  (* returns last element of l a list *)
+    match list with
+      | [] -> ""
+      | [x] -> x
+      | _ :: t -> lastElement t;;
+
+let rec pair_to_list p = 
+    match p with
+      | Nil -> []
+      | Pair(a,b) -> a :: pair_to_list b 
+      | single -> [single]
+
+let rec  no_nested_begin exps = match exps with
+                                          | Pair(Pair(Symbol "begin", restExp), Nil) -> no_nested_begin restExp
+                                          | Pair(a, b) -> Pair(a, no_nested_begin b)
+                                          | exp -> exp;;
+
+(* ------------------------------------------------------------------------------------------------------------------ *)
+
+let rec tag_parse sexpr =  
+  match sexpr with
+  | Bool _ | Char _ | Number _ | String _ -> Const(Sexpr(sexpr))
+  | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("define"), Pair(Symbol(name), Pair(exp, Nil))) -> Def(tag_parse (Symbol(name)), tag_parse exp)
+  | Pair(Symbol("set!"), Pair(Symbol(name), Pair(exp, Nil))) -> Set(tag_parse (Symbol(name)), tag_parse exp) 
+  | Symbol(x) -> if (List.exists (fun a-> a=x) reserved_word_list)
+                 then raise X_syntax_error
+                 else Var(x)
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil)))) ->
+          If(tag_parse test, tag_parse dit, tag_parse dif)
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Nil))) ->
+          If(tag_parse test, tag_parse dit, Const(Void))
+  | Pair(Symbol("or"), orExps) ->  
+        (match orExps with
+        | Nil -> tag_parse (Bool(false))
+        | Pair(a,b) -> Or(List.map tag_parse (pair_to_list orExps))
+        | _-> raise X_syntax_error)
+  | Pair(Symbol("lambda"), Pair(args, body)) -> parse_lambda args body      (* "(lambda (a b) (+ a b) (- a b))" *) 
+(* ----------------------------------------------------------explicitSequences parser-------------------------------------------------------- *)
+  | Pair(Symbol "begin", exps) -> 
+        if exps = Nil then Const(Void)
+        else
+            let exps1 = no_nested_begin exps in
+            parse_sequence exps1
+    
+(* ----------------------------------------------------------macros parser-------------------------------------------------------- *)
+
+  | Pair(Symbol("quasiquote"), Pair(exp, Nil)) -> parseQuasiquote exp
+  | Pair(Symbol "cond", ribs) -> tag_parse (parseCond ribs)
+  | Pair(Symbol("and"), andExps) -> tag_parse (parseAnd andExps) 
+  | Pair(Symbol("let"), Pair(bindings, body)) -> tag_parse (parse_let bindings body)  (* (let ((a 1) (b 2)) (f a) (f b)) ==> *)
+                                                                                                 (* ((lambda (a b) (+ a b) (f a b)) 1 2) *)
+  | Pair(Symbol("let*"), Pair(bindings, body)) -> tag_parse (parse_let_star bindings body)
+  | Pair(Symbol("letrec"), Pair(bindings, body)) -> tag_parse (parse_let_rec bindings body)
+  | Pair(Symbol("define"), Pair(Pair(Symbol(varName), argList), body)) -> tag_parse (parse_mit_define varName argList body)
+  | Pair(Symbol "pset!", body) -> tag_parse (parse_Pset body)
+
+(* ----------------------------------------------------------application parser-------------------------------------------------------- *)
+  | Pair(funcExp, params) ->   Applic(tag_parse funcExp, List.map tag_parse (pair_to_list params)) 
+      (* (func 1 2) *)
+
+  | _ -> raise X_syntax_error 
+(* ----------------------------------------------------------start macro functions-------------------------------------------------------- *)
+
+and parseQuasiquote exp =
+    match exp with
+    | Pair(Symbol("unquote"), Pair(x, Nil)) -> tag_parse x
+    | Pair(Symbol("unquote-splicing"), Pair(x, Nil)) -> raise X_syntax_error
+    | Nil | Symbol _ ->  tag_parse (Pair(Symbol("quote"), Pair(exp, Nil)))
+    (* case 4 wat , probably not required*)
+    | Pair(Pair(Symbol("unquote-splicing"), Pair(x, Nil)), b) -> Applic(Var("append"), [tag_parse x; tag_parse (Pair(Symbol("quasiquote"), Pair(b, Nil)))]) 
+    | Pair(a, Pair(Symbol("unquote-splicing"), Pair(x, Nil))) -> Applic(Var("cons"), [tag_parse (Pair(Symbol("quasiquote"), Pair(a, Nil))); tag_parse x]) 
+    | Pair(a, b) -> Applic(Var("cons"), [tag_parse (Pair(Symbol("quasiquote"), Pair(a, Nil))); tag_parse (Pair(Symbol("quasiquote"), Pair(b, Nil)))]) 
+    | Bool _ | Char _ | Number _ | String _ -> tag_parse exp
+
+and parseCond ribs =
+     match ribs with   
+   (* Pair(rib, restRibs) *) 
+    | Pair(Pair(test, Pair(Symbol("=>"), Pair(body, Nil))), Nil) ->  (* case 2 *)
+                                                                  if body = Nil then raise X_syntax_error 
+                                                                  else
+                                                                      Pair(Symbol("let"), Pair(Pair(Pair(Symbol("value"), Pair(test, Nil)), 
+                                                                                                    Pair(Pair(Symbol("f"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(body, Nil))), Nil)), 
+                                                                                                          Nil)), 
+                                                                                              Pair(Pair(Symbol("if"), Pair(Symbol("value"), Pair(Pair(Pair(Symbol("f"), Nil), Pair(Symbol("value"), Nil)), Nil))), Nil)))
+    | Pair(Pair(test, Pair(Symbol("=>"), Pair(body, Nil))), restRibs) ->  (* case 2 *)
+                                                                  if body = Nil then raise X_syntax_error 
+                                                                  else
+                                                                      Pair(Symbol("let"), Pair(Pair(Pair(Symbol("value"), Pair(test, Nil)), 
+                                                                                                    Pair(Pair(Symbol("f"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(body, Nil))), Nil)), 
+                                                                                                          Pair(Pair(Symbol("rest"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(parseCond restRibs, Nil))), Nil)), Nil))), 
+                                                                                              Pair(Pair(Symbol("if"), Pair(Symbol("value"), Pair(Pair(Pair(Symbol("f"), Nil), Pair(Symbol("value"), Nil)), Pair(Pair(Symbol("rest"), Nil), Nil)))), Nil)))    
+    | Pair(Pair(Symbol("else"), body), restRibs) ->  (* case 3 *)
+                                            if body = Nil then raise X_syntax_error 
+                                            else
+                                                Pair(Symbol("begin"), body)
+    | Pair(Pair(test, body), Nil) ->  (* case 1 *)
+                                   if body = Nil then raise X_syntax_error 
+                                   else
+                                       Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), body), Nil)))
+    | Pair(Pair(test, body), restRibs) ->  (* case 1 *)
+                                   if body = Nil then raise X_syntax_error 
+                                   else
+                                       Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), body), Pair(parseCond restRibs, Nil))))
+    | _ -> raise X_syntax_error                                                         
+(* ----------------------------------------------------------calculations case 2-------------------------------------------------------- *)
+(* (let a b) ---> Pair(Symbol("let"), Pair(a, Pair(b, Nil)))
+a = Pair(a1, Pair(a2, Pair(a3, Nil)))
+b = Pair(Symbol("if"), Pair(Symbol("value"), Pair(Pair(Symbol("f"), Pair(Symbol("value"), Nil)), Pair(Pair(Symbol("rest"), Nil), Nil))))
+a1 = Pair(Symbol("value"), Pair(test, Nil))
+a2 = Pair(Symbol("f"), Pair(Pair(Symbol("Lambda"), Pair(argList1, Pair(body, Nil))), Nil))
+a3 = Pair(Symbol("rest"), Pair(Pair(Symbol("Lambda"), Pair(argList2, Pair(parseCond restRibs, Nil))), Nil))
+a = Pair(a1, 
+         Pair(a2, 
+              Pair(a3, Nil)))
+Pair(Symbol("let"), Pair(a, 
+                         Pair(b, Nil)))
+(let ((value ⟨test⟩)
+        (f (lambda () ⟨exprf⟩))
+        (rest (lambda () ⟨continue with cond-ribs⟩)))
+        (if value
+            (f value)
+            (rest))) *)
+(* ----------------------------------------------------------end calculations-------------------------------------------------------- *)
+
+and parse_let bindings body = 
+  if body = Nil then raise X_syntax_error 
+  else
+        Pair(Pair(Symbol("lambda"), Pair(get_args bindings, body)), get_vals bindings)
+
+and get_args bindings =
+    match bindings with
+    | Nil -> Nil
+    | Pair(Pair(arg, Pair(value, Nil)), restBinds) -> Pair(arg, get_args restBinds)
+    | _ -> raise X_syntax_error
+
+and get_vals bindings =
+    match bindings with
+    | Nil -> Nil
+    | Pair(Pair(arg, Pair(value, Nil)), restBinds) -> Pair(value, get_vals restBinds)
+    | _ -> raise X_syntax_error
+
+and parse_let_star bindings body =
+  if body = Nil then raise X_syntax_error 
+  else
+    match bindings with
+    | Nil -> Pair(Symbol("let"), Pair(bindings, body))
+    | Pair(single, Nil) -> Pair(Symbol("let"), Pair(Pair(single, Nil), body))
+    | Pair(first, restBinds) -> Pair(Symbol("let"), Pair(Pair(first, Nil), Pair(parse_let_star restBinds body, Nil)))
+    | _-> raise X_syntax_error
+
+and parse_let_rec bindings body = 
+  if body = Nil then raise X_syntax_error 
+  else
+    match bindings with
+    | Pair(Pair(Symbol(argName), Pair(exp, Nil)), rest) -> Pair(Symbol("let"), Pair(parse_let_rec_bindings bindings, parse_let_rec_body bindings body))
+    | _ -> raise X_syntax_error 
+
+and parse_let_rec_bindings bindings = 
+    match bindings with
+    | Nil -> Nil
+    | Pair(Pair(Symbol(argName), Pair(exp, Nil)), rest) -> Pair(Pair(Symbol(argName), Pair(Symbol("qoute"), Pair(Symbol("something"), Nil))), parse_let_rec_bindings rest)
+    | _ -> raise X_syntax_error
+
+and parse_let_rec_body bindings body = 
+    match bindings with
+    | Nil -> Pair(Symbol("let"), Pair(Nil, body)) (* is last exp "let" really needed in letrec? *)
+    | Pair(Pair(Symbol(argName), Pair(exp, Nil)), rest) -> Pair(Pair(Symbol("set!"), Pair(Symbol(argName), Pair(exp, Nil))), parse_let_rec_body rest body)
+    | _ -> raise X_syntax_error
+
+and parseAnd exps =
+    match exps with
+    | Nil -> Bool(true)
+    | Pair(single, Nil) -> single
+    | Pair(first, rest) -> Pair(Symbol("if"), Pair(first, Pair((parseAnd rest), Pair(Bool(false), Nil))))
+    | _ -> raise X_syntax_error
+
+and parse_mit_define varName argList body = 
+    match body with
+    | Nil -> raise X_syntax_error
+    | _ -> Pair(Symbol("define"), Pair(Symbol(varName), Pair(Pair(Symbol("lambda"), Pair(argList, body)), Nil)))
+
+and parse_Pset body = 
+  if body = Nil then raise X_syntax_error 
+  else
+    match body with
+    | Pair(single, Nil) -> Pair(Symbol("set!"), single)
+    | Pair(Pair(Symbol(vi), Pair(expri, Nil)), restBinds) -> 
+
+          Pair(Symbol("let"), Pair(Pair(Pair(Symbol("temp1"), Pair(expri, Nil)), 
+                                        Pair(Pair(Symbol("temp2"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(parse_Pset restBinds, Nil), Nil))), Nil)), 
+                                            Pair(Pair(Symbol("temp3"), Pair(Pair(Symbol("lambda"), Pair(Pair(Symbol("t"), Nil), Pair(Pair(Symbol("set!"), Pair(Symbol(vi), Pair(Symbol("t"), Nil))), Nil))), Nil)), Nil))), 
+                                  Pair(Pair(Symbol("temp2"), Nil), Pair(Pair(Symbol("temp3"), Pair(Symbol("temp1"), Nil)), Nil)))) 
+    | _ -> raise X_syntax_error
+
+(* ----------------------------------------------------------calculations Pset!-------------------------------------------------------- *)
+(* (let ((temp1 expri)
+         (temp2 (lambda () (parse_Pset restBinds)))
+         (temp3 (lambda (t) (set! vi t)))
+            )
+        (temp2)
+        (temp3 temp1)
+    )                                     *)
+
+(* (let a b) ---> Pair(Symbol("let"), Pair(a, Pair(b, Nil)))
+a = Pair(a1, 
+         Pair(a2, 
+              Pair(a3, Nil)))
+
+b = Pair(b1, Pair(b2, Nil))            
+Pair(Symbol("let"), Pair(Pair(a1, 
+                              Pair(a2, 
+                                   Pair(a3, Nil))), 
+                         Pair(b1, Pair(b2, Nil))))      *)
+
+(* a1 = Pair(Symbol("temp1"), Pair(expri, Nil))
+a2 = Pair(Symbol("temp2"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(parse_Pset restBinds, Nil), Nil))), Nil))
+a3 = Pair(Symbol("temp3"), Pair(Pair(Symbol("lambda"), Pair(Pair(Symbol(t), Nil), Pair(Pair(Symbol("set!"), Pair(Symbol(vi), Pair(Symbol(t), Nil))), Nil))), Nil))
+b1 = Pair(Symbol("temp2"), Nil)
+b2 = Pair(Symbol("temp3"), Pair(Symbol("temp1"), Nil))
+
+Pair(Symbol("let"), Pair(Pair(Pair(Symbol("temp1"), Pair(expri, Nil)), 
+                              Pair(Pair(Symbol("temp2"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(parse_Pset restBinds, Nil), Nil))), Nil)), 
+                                   Pair(Pair(Symbol("temp3"), Pair(Pair(Symbol("lambda"), Pair(Pair(Symbol(t), Nil), Pair(Pair(Symbol("set!"), Pair(Symbol(vi), Pair(Symbol(t), Nil))), Nil))), Nil)), Nil))), 
+                         Pair(Pair(Symbol("temp2"), Nil), Pair(Pair(Symbol("temp3"), Pair(Symbol("temp1"), Nil)), Nil))))  *)
+(* ----------------------------------------------------------end calculations-------------------------------------------------------- *)
+(* ----------------------------------------------------------end macro functions-------------------------------------------------------- *)
+(* ----------------------------------------------------------lambda parser-------------------------------------------------------- *)
+and parse_lambda args body = (* (lambda () (+ 1 1))    (lambda () 10 20) *)
+    
+    let names = argsNames args in
+    if (List.exists (fun s-> (List.exists (fun r-> r=s ) reserved_word_list) ) names) 
+    then raise X_syntax_error
+    else
+        if isSimple args (* args.last=Nil || arg=Nil *)
+        then  (* case lambdaSimple *)
+            (match body with 
+            | Nil -> raise X_syntax_error
+            | Pair(Pair(a, b), Nil) ->  LambdaSimple(names, tag_parse (Pair(a, b)))
+            | _-> LambdaSimple(names, parse_sequence body) ) 
+
+        else (* case LambdaOpt *)
+            (match args with 
+            | Symbol(name) -> if (List.exists (fun a-> a=name) reserved_word_list)
+                                  then raise X_syntax_error
+                                  else LambdaOpt([], name, tag_parse body)    (*case variadic*)
+            | Pair(a, b) ->  
+                      let lastArg = lastElement names in 
+                      let reversedList = (List.rev names) in
+                      let tailedList = (List.tl reversedList) in
+                      let shortedList = (List.rev tailedList) in (* = argsNames without last element *)
+                      (match body with 
+                      | Nil -> raise X_syntax_error
+                      | Pair(Pair(a, b), Nil) ->  LambdaOpt(shortedList, lastArg, tag_parse (Pair(a, b)))
+                      | _-> LambdaOpt(shortedList, lastArg, parse_sequence body) )
+            | _ -> raise X_syntax_error )
+
+and parse_sequence exps = 
+      (match exps with
+      | Nil -> raise X_syntax_error
+      | Pair(single, Nil) -> tag_parse single
+      | Pair(a,b) -> Seq(List.map tag_parse (pair_to_list exps))    (* case list of element *)
+      | _-> raise X_syntax_error)
+
+and argsNames args = 
+    List.map (fun arg-> (match arg with 
+                        | Symbol(name) -> name 
+                        | _-> raise X_syntax_error)) 
+             (pair_to_list args)
+
+and isSimple args =
+    match args with 
+    | Nil -> true 
+    | Pair(Symbol _, Symbol _) -> false
+    | Pair(Symbol _, rest) -> isSimple rest
+    | _ -> raise X_syntax_error
+    ;;
+
+let tag_parse_expressions sexprList = List.map tag_parse sexprList ;;
+
+
+end;;(*  struct Tag_Parser *)
+ *)
+
+
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+(* ------------------------------------------------------------------------------------------------------------------ *)
+
+
+
+
 #use "tag-parser.ml";;
 
 type var = 
@@ -59,6 +862,9 @@ let rec expr'_eq e1 e2 =
   | _ -> false;;	
                       
 exception X_syntax_error;;
+exception X_syntax_error1;;
+exception X_syntax_error2;;
+
 
 module type SEMANTICS = sig
   val run_semantics : expr -> expr'
@@ -69,17 +875,243 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let rec annotate_lexical_addresses e =  
+    match e with
+    | Const(c) -> Const'(c)
+    | Var(varName) -> Var'(VarFree(varName))
+    | If(test, dit, dif) -> If'(annotate_lexical_addresses test, annotate_lexical_addresses dit, annotate_lexical_addresses dif)
+    | Seq(l) -> Seq'(List.map annotate_lexical_addresses l)
+    | Set(v, exp) -> 
+               let var = annotate_lexical_addresses v in
+                (match var with
+                | Var'(x) -> Set'(x, annotate_lexical_addresses exp)
+                | _-> raise X_syntax_error)
+    | Def(v, exp) -> 
+                let var = annotate_lexical_addresses v in
+                (match var with
+                | Var'(x) -> Def'(x, annotate_lexical_addresses exp)
+                | _-> raise X_syntax_error)
+    
+    | Or(l) -> Or'(List.map annotate_lexical_addresses l)
+    | LambdaSimple(args, body) -> LambdaSimple'(args, annotate_lexical_addresses_lambda [args] body)
+    | LambdaOpt(args, last, body) -> LambdaOpt'(args, last, annotate_lexical_addresses_lambda [List.append args [last]] body)
+    | Applic(e, exps) -> Applic'(annotate_lexical_addresses e, List.map annotate_lexical_addresses exps)
+    (* | _-> raise X_syntax_error *)
+(* ----------------------------------------------------------lexical_addresses lambda-------------------------------------------------------- *)
+(* args: [args1, args2, ...] *)
+and annotate_lexical_addresses_lambda args body =
+    match body with
+    | Const(c) -> Const'(c)
+    | Var(varName) ->  
+        let (major, minor) = get_major_minor varName args in
+        (match (major, minor) with
+        | (-1, _) -> Var'(VarFree(varName))
+        | (0, _) -> Var'(VarParam(varName, minor))
+        | _-> Var'(VarBound(varName, major-1, minor)) 
+        )
+    | If(test, dit, dif) -> If'(annotate_lexical_addresses_lambda args test, annotate_lexical_addresses_lambda args dit, annotate_lexical_addresses_lambda args dif)
+    | Seq(l) -> Seq'(List.map (fun e-> annotate_lexical_addresses_lambda args e) l)
+    | Set(v, exp) -> 
+               let var = annotate_lexical_addresses_lambda args v in
+                (match var with
+                | Var'(x) -> Set'(x, annotate_lexical_addresses_lambda args exp)
+                | _-> raise X_syntax_error)
+    | Def(v, exp) -> 
+                let var = annotate_lexical_addresses_lambda args v in
+                (match var with
+                | Var'(x) -> Def'(x, annotate_lexical_addresses_lambda args exp)
+                | _-> raise X_syntax_error)
+    | Or(l) -> Or'(List.map (fun e-> annotate_lexical_addresses_lambda args e) l)
+    | LambdaSimple(args1, body1) -> LambdaSimple'(args1, annotate_lexical_addresses_lambda (List.append [args1] args) body1)
+    | LambdaOpt(args1, last1, body1) -> LambdaOpt'(args1, last1, annotate_lexical_addresses_lambda (List.append [List.append args1 [last1]] args) body1)
+    | Applic(e, exps) -> Applic'(annotate_lexical_addresses_lambda args e, List.map (fun e-> annotate_lexical_addresses_lambda args e) exps)
+    (* | _-> raise X_syntax_error *)
+
+
+and get_minor e l = (* returns e's index in l *)
+    if e = List.nth l 0
+    then 0
+    else 1 + get_minor e (List.tl l)
+
+and get_major e lol = (* returns e's list index in lol. returns lol.length if e isn't there *)
+    if lol != []
+    then if List.mem e (List.nth lol 0)
+         then 0
+         else 1 + get_major e (List.tl lol)
+    else 0
+    
+(* lol means list of lists 
+   returns (e's list index in lol, minor) *)
+and get_major_minor e lol = 
+    let major = get_major e lol in 
+    if major = List.length lol
+    then (-1, -1)
+    else (major, get_minor e (List.nth lol major))
+    
+;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+let rec tp_calls e in_tp =
+    match e with
+    | Const'(_) | Var'(_) -> e
+    | If'(test, dit, dif) -> If'(tp_calls test false, tp_calls dit in_tp, tp_calls dif in_tp)
+    | Seq'(l) -> 
+           let shortedList = List.rev (List.tl (List.rev l)) in
+           let last = lastOf l in
+           Seq'(List.append (List.map (fun e-> tp_calls e false) shortedList) [tp_calls last in_tp])
+    | Set'(v, exp) -> Set'(v, tp_calls exp false)
+    | Def'(v, exp) -> Def'(v, tp_calls exp false)
+    | Or'(exps) -> 
+    (* exps can't be [] due to tag-parser *)
+           let shortedList = List.rev (List.tl (List.rev exps)) in
+           let last = lastOf exps in
+           Or'(List.append (List.map (fun e-> tp_calls e false) shortedList) [tp_calls last in_tp])
+    | LambdaSimple'(args, body) -> LambdaSimple'(args, tp_calls body true)
+    | LambdaOpt'(args, last, body) -> LambdaOpt'(args, last, tp_calls body true)
+    | Applic'(e, exps) ->
+          if in_tp
+          then ApplicTP'(tp_calls e false, List.map (fun e-> tp_calls e false) exps)
+          else Applic'(tp_calls e false, List.map (fun e-> tp_calls e false) exps)   
+    | _-> raise X_syntax_error
 
-let box_set e = raise X_not_yet_implemented;;
+and lastOf list =  (* returns last element of a non-empty list *)
+    match list with
+      | [x] -> x
+      | _ :: t -> lastOf t
+      | _-> raise X_syntax_error;;
+
+let annotate_tail_calls e = tp_calls e false;;
+
+let rec boxing e =
+    match e with
+        | Var'(v) -> (match v with
+                     | VarParam(name, m) -> BoxGet'(v) 
+                     | VarBound(name, _,m) -> BoxGet'(v) 
+                     | VarFree(name) -> Var'(v)) 
+        | Set'(v, exp) -> (match v with
+                          | VarParam(name, m) -> BoxSet'(v, boxing exp) 
+                          | VarBound(name, _,m) -> BoxSet'(v, boxing exp)
+                          | VarFree(name) -> Set'(v, boxing exp) )
+        | Const'(_) -> e
+        | Or'(exps) -> Or'(List.map (fun e-> boxing e) exps)
+        | If'(test, dit, dif) -> If'(boxing test, boxing dit, boxing dif)
+        | Seq'(l) -> Seq'(List.map (fun e-> boxing e) l)
+        | Def'(v, exp) -> Def'(v, boxing exp)
+        | LambdaSimple'(args, body) -> 
+                let args_to_be_boxed_list = args_for_boxing args 0 in(* args_for_boxing args body 0 [(arg1_to_be_boxed, its index),...,(argn_to_be_boxed, its index)] *)
+                if args_to_be_boxed_list = []
+                then LambdaSimple'(args, boxing body)
+                else 
+                    let body_after_Box_set_get = boxing body in
+                    let init_seq_of_body = List.map (fun (arg,i)-> Set'(VarParam(arg, i), Box'(VarParam(arg,i)))) args_to_be_boxed_list in
+                    (match body_after_Box_set_get with  (* preventing nested sequence *)
+                                     | Seq'(l) -> LambdaSimple'(args, Seq'(List.append init_seq_of_body l)) 
+                                     | _-> LambdaSimple'(args, Seq'(List.append init_seq_of_body [body_after_Box_set_get]))) 
+        | LambdaOpt'(args, last, body) ->  
+                let args_to_be_boxed_list = args_for_boxing (List.append args [last]) 0 in (* args_for_boxing args body 0 [(arg1_to_be_boxed, its index),...,(argn_to_be_boxed, its index)] *)
+                if args_to_be_boxed_list = []
+                then LambdaOpt'(args, last, boxing body)
+                else 
+                    let body_after_Box_set_get = boxing body in
+                    let init_seq_of_body = List.map (fun (arg,i)-> Set'(VarParam(arg, i), Box'(VarParam(arg,i)))) args_to_be_boxed_list in
+                    (match body_after_Box_set_get with  (* preventing nested sequence *)
+                                     | Seq'(l) -> LambdaOpt'(args, last, Seq'(List.append init_seq_of_body l)) 
+                                     | _-> LambdaOpt'(args, last, Seq'(List.append init_seq_of_body [body_after_Box_set_get])))
+        | Applic'(e, exps) -> Applic'(boxing e, List.map (fun exp-> boxing exp) exps)
+        | ApplicTP'(e, exps) -> ApplicTP'(boxing e, List.map (fun exp-> boxing exp) exps)
+        | _-> raise X_syntax_error1 (* won't get here *)
+        
+        
+and args_for_boxing args i = 
+    match args with
+    | [] -> []
+    | [a] -> [(a,i)] 
+    | a::b -> List.append [(a,i)] (args_for_boxing b (i+1))
+
+(* and change_to_box_set_get body args_list = 
+    match body with
+        | Var'(v) -> (match v with
+                     | VarParam(name, m) -> if List.mem (name, m) args_list then BoxGet'(v) else raise X_syntax_error1
+                     | VarBound(name, _,m) -> if List.mem (name, m) args_list then BoxGet'(v) else raise X_syntax_error1
+                     | _-> raise X_syntax_error1) 
+        | Set'(v, exp) -> (match v with
+                          | VarParam(name, m) -> if List.mem (name, m) args_list then BoxSet'(v, exp) else raise X_syntax_error2
+                          | VarBound(name, _,m) -> if List.mem (name, m) args_list then BoxSet'(v, exp) else raise X_syntax_error2
+                          | _-> raise X_syntax_error2 )
+        | If'(test, dit, dif) -> If'(change_to_box_set_get test args_list, change_to_box_set_get dit args_list, change_to_box_set_get dif args_list)
+        | Seq'(exps) -> Seq'(List.map (fun e-> change_to_box_set_get e args_list) exps)
+        | Def'(v, exp) -> Def'(v, change_to_box_set_get exp args_list)
+        | Or'(exps) -> Or'(List.map (fun e-> change_to_box_set_get e args_list) exps)
+        | LambdaSimple'(args, body) -> LambdaSimple'(args, change_to_box_set_get body args_list)
+        | LambdaOpt'(args, last, body) -> LambdaOpt'(args, last, change_to_box_set_get body args_list)
+        | Applic'(e, exps) -> Applic'(change_to_box_set_get e args_list, List.map (fun e-> change_to_box_set_get e args_list) exps)
+        | _-> body won't get here *)
+;;
+
+let box_set e = boxing e ;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
+
+(* let run_semantics expr =
+  box_set
+       (annotate_lexical_addresses expr);; *)
   
-end;; (* struct Semantics *)
+end;; (*struct Semantics *)
+
+
+
+
+
+
+(*  ▶ Read occurrence within a closure
+    ▶ Write occurrence within another closure
+    ▶ Both occurrences already share a rib *)
+
+    (* 1. Seq' ([...; <write-occur>; ...; E; ...]) where E is an expr that contains a <read-occur>.
+       2. Seq' ([...; <read-occur>;  ...; E; ...]) where E is an expr that contains a <write-occur>. *)
+(* and args_for_boxing args body argIndex =
+
+    match args with
+    | [] -> []
+    | [arg] -> check arg body [false, false, false, false, false] argIndex
+    | arg :: rest -> List.append (check arg body [false, false, false, false, false] argIndex) (args_for_boxing rest body (argIndex+1)) *)
+    (* if args = [] then []
+    else
+        let occursList = read_write_occurs_list args body in  = [(Var'1, "read"),...,(Var'n, "write")] *)
+(* checks if arg needs to be boxed *)
+(* and check arg body flags argIndex =
+    match flags with
+    (* | *)
+    (* | [true,...,true] -> [(arg, argIndex)] *)
+    | _-> match body with
+          | Seq'(s) ->  
+          |
+          | *)
+
+(* and read_write_occurs_list args body =
+    match args with 
+                    | [argName] -> read_write_occurs_list_per_arg argName body []
+                    | argName :: restArgs -> List.append (read_write_occurs_list_per_arg argName body []) (read_write_occurs_list restArgs body)
 
+and read_write_occurs_list_per_arg argName body l =
+    match body with
+        | Var'(v) -> (match v with
+                     | VarParam(arg_name1, _) -> if arg_name1=argName then List.append l [(v, "read")]
+                     | VarBound(arg_name1, _,_) -> if arg_name1=argName then List.append l [(v, "read")] )
+        | Set'(v, exp) -> (match v with
+                          | VarParam(arg_name1, _) -> if arg_name1=argName then List.append l [(v, "write")]
+                          | VarBound(arg_name1, _,_) -> if arg_name1=argName then List.append l [(v, "write")] )
+         
+        | If'(test, dit, dif) -> List.append (List.append (read_write_occurs_list_per_arg argName test l) (read_write_occurs_list_per_arg argName dit [])) (read_write_occurs_list_per_arg argName dif [])
+        | Seq'(exps) -> read_write_occurs_list_per_arg argName exps l
+        | Def'(v, exp) -> read_write_occurs_list_per_arg argName exp l
+        | Or'(exps) -> read_write_occurs_list_per_arg argName exps l
+        | LambdaSimple'(args, body) -> read_write_occurs_list_per_arg argName body l
+        | LambdaOpt'(args, last, body) -> read_write_occurs_list_per_arg argName body l
+        | Applic'(e, exps) -> List.append (read_write_occurs_list_per_arg argName e l) (read_write_occurs_list_per_arg argName exps []) 
+        | _-> l case Const' 
 
+and should_be_boxed args body = 
+*)
\ No newline at end of file
diff --git a/stdlib.scm b/stdlib.scm
index 2e4a76e..948caed 100644
--- a/stdlib.scm
+++ b/stdlib.scm
@@ -20,20 +20,42 @@
 
 
 (define fold-left 
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
-
-(define fold-right
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+	(let ((car car) (cdr cdr) (null? null?))
+		 (lambda (f acc l)
+		 	(if (null? l)
+			 	acc
+				(fold-left f (f acc (car l)) (cdr l))
+			)
+		 )
+	)
+)
+
+(define fold-right 
+	(let ((car car) (cdr cdr) (null? null?))
+		 (lambda (f acc l)
+		 	(if (null? l)
+			 	acc
+				(f (car l) (fold-right f acc (cdr l)))
+			)
+		 )
+	)
+)
 
 (define cons*
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
-
+    (let ((null? null?)
+          (car car)
+          (cdr cdr)
+          (cons cons))
+      	 (letrec ((consrec* (lambda (vdic)
+                         	  (if (null? (cdr vdic))
+                              (car vdic)
+                              (cons (car vdic) (consrec* (cdr vdic)))
+							  )
+							)
+				  ))
+				 (lambda vdic (consrec* vdic))
+		  )))
+		  
 (define append
   (let ((null? null?)
 	(fold-right fold-right)
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..cd30c93 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,3 +1,4 @@
+
 #use "reader.ml";;
 
 type constant =
@@ -43,6 +44,8 @@ let rec expr_eq e1 e2 =
 	
                        
 exception X_syntax_error;;
+exception X_syntax_error1;;
+
 
 module type TAG_PARSER = sig
   val tag_parse_expressions : sexpr list -> expr list
@@ -58,8 +61,307 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+(* ----------------------------------------------------------help functions-------------------------------------------------------- *)
+
+let rec lastElement list =  (* returns last element of l a list *)
+    match list with
+      | [] -> ""
+      | [x] -> x
+      | _ :: t -> lastElement t;;
+
+let rec pair_to_list p = 
+    match p with
+      | Nil -> []
+      | Symbol(_) -> [p]
+      | Pair(a,b) -> a :: pair_to_list b 
+      | _-> raise X_syntax_error1
+
+let rec  no_nested_begin exps = match exps with
+                                | Pair(Pair(Symbol "begin", restExp), Nil) -> no_nested_begin restExp
+                                | Pair(a, b) -> Pair(a, no_nested_begin b)
+                                | exp -> exp;;
+
+(* ------------------------------------------------------------------------------------------------------------------ *)
+
+let rec tag_parse sexpr =  
+  match sexpr with
+  | Bool _ | Char _ | Number _ | String _ -> Const(Sexpr(sexpr))
+  | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("define"), Pair(Symbol(name), Pair(exp, Nil))) -> Def(tag_parse (Symbol(name)), tag_parse exp)
+  | Pair(Symbol("set!"), Pair(Symbol(name), Pair(exp, Nil))) -> Set(tag_parse (Symbol(name)), tag_parse exp) 
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil)))) ->
+          If(tag_parse test, tag_parse dit, tag_parse dif)
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Nil))) ->
+          If(tag_parse test, tag_parse dit, Const(Void))
+  | Pair(Symbol("or"), orExps) ->  
+        (match orExps with
+        | Nil -> tag_parse (Bool(false))
+        | Pair(a,b) -> Or(List.map tag_parse (pair_to_list orExps))
+        | _-> raise X_syntax_error)
+  | Pair(Symbol("lambda"), Pair(args, body)) -> parse_lambda args body      (* "(lambda (a b) (+ a b) (- a b))" *) 
+(* ----------------------------------------------------------explicitSequences parser-------------------------------------------------------- *)
+  | Pair(Symbol "begin", exps) -> 
+        if exps = Nil then Const(Void)
+        else
+            let exps1 = no_nested_begin exps in
+            parse_sequence exps1
+    
+(* ----------------------------------------------------------macros parser-------------------------------------------------------- *)
+
+  | Pair(Symbol("quasiquote"), Pair(exp, Nil)) -> parseQuasiquote exp
+  | Pair(Symbol "cond", ribs) -> tag_parse (parseCond ribs)
+  | Pair(Symbol("and"), andExps) -> tag_parse (parseAnd andExps) 
+  | Pair(Symbol("let"), Pair(bindings, body)) -> tag_parse (parse_let bindings body)  (* (let ((a 1) (b 2)) (f a) (f b)) ==> *)
+                                                                                                 (* ((lambda (a b) (+ a b) (f a b)) 1 2) *)
+  | Pair(Symbol("let*"), Pair(bindings, body)) -> tag_parse (parse_let_star bindings body)
+  | Pair(Symbol("letrec"), Pair(bindings, body)) -> tag_parse (parse_let_rec bindings body)
+  | Pair(Symbol("define"), Pair(Pair(Symbol(varName), argList), body)) -> tag_parse (parse_mit_define varName argList body)
+  | Pair(Symbol "pset!", body) -> tag_parse (parse_Pset body)
+
+(* ----------------------------------------------------------application parser-------------------------------------------------------- *)
+  | Pair(funcExp, params) ->   Applic(tag_parse funcExp, List.map tag_parse (pair_to_list params)) 
+      (* (func 1 2) *)
+
+  | Symbol(x) -> if (List.mem x reserved_word_list)
+                 then raise X_syntax_error
+                 else Var(x)
+
+  | _ -> raise X_syntax_error
+(* ----------------------------------------------------------start macro functions-------------------------------------------------------- *)
+
+and parseQuasiquote exp =
+    match exp with
+    | Pair(Symbol("unquote"), Pair(x, Nil)) -> tag_parse x
+    | Pair(Symbol("unquote-splicing"), Pair(x, Nil)) -> tag_parse (Pair(Symbol("quote"), Pair(Pair(Symbol("unquote-splicing"), Pair(x, Nil)), Nil)))
+    | Nil | Symbol _ ->  tag_parse (Pair(Symbol("quote"), Pair(exp, Nil)))
+    (* case 4 wat , probably not required*)
+    | Pair(Pair(Symbol("unquote-splicing"), Pair(x, Nil)), b) -> Applic(Var("append"), [tag_parse x; tag_parse (Pair(Symbol("quasiquote"), Pair(b, Nil)))]) 
+    | Pair(a, Pair(Symbol("unquote-splicing"), Pair(x, Nil))) -> Applic(Var("cons"), [tag_parse (Pair(Symbol("quasiquote"), Pair(a, Nil))); tag_parse x]) 
+    | Pair(a, b) -> Applic(Var("cons"), [tag_parse (Pair(Symbol("quasiquote"), Pair(a, Nil))); tag_parse (Pair(Symbol("quasiquote"), Pair(b, Nil)))]) 
+    | Bool _ | Char _ | Number _ | String _ -> tag_parse exp
+
+and parseCond ribs =
+     match ribs with   
+   (* Pair(rib, restRibs) *) 
+    | Pair(Pair(test, Pair(Symbol("=>"), Pair(body, Nil))), Nil) ->  (* case 2 *)
+                                                                  if body = Nil then raise X_syntax_error 
+                                                                  else
+                                                                      Pair(Symbol("let"), Pair(Pair(Pair(Symbol("value"), Pair(test, Nil)), 
+                                                                                                    Pair(Pair(Symbol("f"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(body, Nil))), Nil)), 
+                                                                                                          Nil)), 
+                                                                                              Pair(Pair(Symbol("if"), Pair(Symbol("value"), Pair(Pair(Pair(Symbol("f"), Nil), Pair(Symbol("value"), Nil)), Nil))), Nil)))
+    | Pair(Pair(test, Pair(Symbol("=>"), Pair(body, Nil))), restRibs) ->  (* case 2 *)
+                                                                  if body = Nil then raise X_syntax_error 
+                                                                  else
+                                                                      Pair(Symbol("let"), Pair(Pair(Pair(Symbol("value"), Pair(test, Nil)), 
+                                                                                                    Pair(Pair(Symbol("f"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(body, Nil))), Nil)), 
+                                                                                                          Pair(Pair(Symbol("rest"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(parseCond restRibs, Nil))), Nil)), Nil))), 
+                                                                                              Pair(Pair(Symbol("if"), Pair(Symbol("value"), Pair(Pair(Pair(Symbol("f"), Nil), Pair(Symbol("value"), Nil)), Pair(Pair(Symbol("rest"), Nil), Nil)))), Nil)))    
+    | Pair(Pair(Symbol("else"), body), restRibs) ->  (* case 3 *)
+                                            if body = Nil then raise X_syntax_error 
+                                            else
+                                                Pair(Symbol("begin"), body)
+    | Pair(Pair(test, body), Nil) ->  (* case 1 *)
+                                   if body = Nil then raise X_syntax_error 
+                                   else
+                                       Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), body), Nil)))
+    | Pair(Pair(test, body), restRibs) ->  (* case 1 *)
+                                   if body = Nil then raise X_syntax_error 
+                                   else
+                                       Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), body), Pair(parseCond restRibs, Nil))))
+    | _ -> raise X_syntax_error                                                         
+(* ----------------------------------------------------------calculations case 2-------------------------------------------------------- *)
+(* (let a b) ---> Pair(Symbol("let"), Pair(a, Pair(b, Nil)))
+a = Pair(a1, Pair(a2, Pair(a3, Nil)))
+b = Pair(Symbol("if"), Pair(Symbol("value"), Pair(Pair(Symbol("f"), Pair(Symbol("value"), Nil)), Pair(Pair(Symbol("rest"), Nil), Nil))))
+a1 = Pair(Symbol("value"), Pair(test, Nil))
+a2 = Pair(Symbol("f"), Pair(Pair(Symbol("Lambda"), Pair(argList1, Pair(body, Nil))), Nil))
+a3 = Pair(Symbol("rest"), Pair(Pair(Symbol("Lambda"), Pair(argList2, Pair(parseCond restRibs, Nil))), Nil))
+a = Pair(a1, 
+         Pair(a2, 
+              Pair(a3, Nil)))
+Pair(Symbol("let"), Pair(a, 
+                         Pair(b, Nil)))
+(let ((value ⟨test⟩)
+        (f (lambda () ⟨exprf⟩))
+        (rest (lambda () ⟨continue with cond-ribs⟩)))
+        (if value
+            (f value)
+            (rest))) *)
+(* ----------------------------------------------------------end calculations-------------------------------------------------------- *)
+
+and parse_let bindings body = 
+  if body = Nil then raise X_syntax_error 
+  else
+        Pair(Pair(Symbol("lambda"), Pair(get_args bindings, body)), get_vals bindings)
+
+and get_args bindings =
+    match bindings with
+    | Nil -> Nil
+    | Pair(Pair(arg, Pair(value, Nil)), restBinds) -> Pair(arg, get_args restBinds)
+    | _ -> raise X_syntax_error
+
+(* letrec problem here: *)
+
+and get_vals bindings =
+    match bindings with
+    | Nil -> Nil
+    | Pair(Pair(arg, Pair(value, Nil)), restBinds) -> Pair(value, get_vals restBinds)
+    | _ -> raise X_syntax_error
+
+and parse_let_star bindings body =
+  if body = Nil then raise X_syntax_error 
+  else
+    match bindings with
+    | Nil -> Pair(Symbol("let"), Pair(bindings, body))
+    | Pair(single, Nil) -> Pair(Symbol("let"), Pair(Pair(single, Nil), body))
+    | Pair(first, restBinds) -> Pair(Symbol("let"), Pair(Pair(first, Nil), Pair(parse_let_star restBinds body, Nil)))
+    | _-> raise X_syntax_error
+
+and parse_let_rec bindings body = 
+  if body = Nil then raise X_syntax_error
+  else
+    match bindings with
+    | Pair(Pair(Symbol(argName), Pair(exp, Nil)), rest) -> Pair(Symbol("let"), Pair(parse_let_rec_bindings bindings, parse_let_rec_body bindings body))
+    | _ -> raise X_syntax_error
+
+and parse_let_rec_bindings bindings = 
+    match bindings with
+    | Nil -> Nil
+    | Pair(Pair(Symbol(argName), Pair(exp, Nil)), rest) -> Pair(Pair(Symbol(argName), Pair(Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)), Nil)), parse_let_rec_bindings rest)
+    | _ -> raise X_syntax_error
+
+and parse_let_rec_body bindings body = 
+    match bindings with
+    | Nil -> body  
+    (* Pair(Pair(Symbol("let"), Pair(Nil,body)), Nil)  /  Pair(Symbol("let"), Pair(Nil, body))  /  Pair(Pair(Symbol("let"), Pair(Nil,body)), Nil)  is last exp "let" really needed in letrec? *)
+    | Pair(Pair(Symbol(argName), Pair(exp, Nil)), rest) -> Pair(Pair(Symbol("set!"), Pair(Symbol(argName), Pair(exp, Nil))), parse_let_rec_body rest body)
+    | _ -> raise X_syntax_error
+
+and parseAnd exps =
+    match exps with
+    | Nil -> Bool(true)
+    | Pair(single, Nil) -> single
+    | Pair(first, rest) -> Pair(Symbol("if"), Pair(first, Pair((parseAnd rest), Pair(Bool(false), Nil))))
+    | _ -> raise X_syntax_error
+
+and parse_mit_define varName argList body = 
+    match body with
+    | Nil -> raise X_syntax_error
+    | _ -> Pair(Symbol("define"), Pair(Symbol(varName), Pair(Pair(Symbol("lambda"), Pair(argList, body)), Nil)))
+
+and parse_Pset body = 
+  if body = Nil then raise X_syntax_error 
+  else
+    match body with
+    | Pair(single, Nil) -> Pair(Symbol("set!"), single)
+    | Pair(Pair(Symbol(vi), Pair(expri, Nil)), restBinds) -> 
+
+          Pair(Symbol("let"), Pair(Pair(Pair(Symbol("temp1"), Pair(expri, Nil)), 
+                                        Pair(Pair(Symbol("temp2"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(parse_Pset restBinds, Nil))), Nil)), 
+                                            Pair(Pair(Symbol("temp3"), Pair(Pair(Symbol("lambda"), Pair(Pair(Symbol("t"), Nil), Pair(Pair(Symbol("set!"), Pair(Symbol(vi), Pair(Symbol("t"), Nil))), Nil))), Nil)), Nil))), 
+                                  Pair(Pair(Symbol("temp2"), Nil), Pair(Pair(Symbol("temp3"), Pair(Symbol("temp1"), Nil)), Nil)))) 
+    | _ -> raise X_syntax_error
+
+(* ----------------------------------------------------------calculations Pset!-------------------------------------------------------- *)
+(* (let ((temp1 expri)
+         (temp2 (lambda () (parse_Pset restBinds)))
+         (temp3 (lambda (t) (set! vi t)))
+            )
+        (temp2)
+        (temp3 temp1)
+    )                                     *)
+
+(* (let a b) ---> Pair(Symbol("let"), Pair(a, Pair(b, Nil)))
+a = Pair(a1, 
+         Pair(a2, 
+              Pair(a3, Nil)))
+
+b = Pair(b1, Pair(b2, Nil))            
+Pair(Symbol("let"), Pair(Pair(a1, 
+                              Pair(a2, 
+                                   Pair(a3, Nil))), 
+                         Pair(b1, Pair(b2, Nil))))      *)
+
+(* a1 = Pair(Symbol("temp1"), Pair(expri, Nil))
+a2 = Pair(Symbol("temp2"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(parse_Pset restBinds, Nil), Nil))), Nil))
+a3 = Pair(Symbol("temp3"), Pair(Pair(Symbol("lambda"), Pair(Pair(Symbol(t), Nil), Pair(Pair(Symbol("set!"), Pair(Symbol(vi), Pair(Symbol(t), Nil))), Nil))), Nil))
+b1 = Pair(Symbol("temp2"), Nil)
+b2 = Pair(Symbol("temp3"), Pair(Symbol("temp1"), Nil))
+
+Pair(Symbol("let"), Pair(Pair(Pair(Symbol("temp1"), Pair(expri, Nil)), 
+                              Pair(Pair(Symbol("temp2"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(parse_Pset restBinds, Nil), Nil))), Nil)), 
+                                   Pair(Pair(Symbol("temp3"), Pair(Pair(Symbol("lambda"), Pair(Pair(Symbol(t), Nil), Pair(Pair(Symbol("set!"), Pair(Symbol(vi), Pair(Symbol(t), Nil))), Nil))), Nil)), Nil))), 
+                         Pair(Pair(Symbol("temp2"), Nil), Pair(Pair(Symbol("temp3"), Pair(Symbol("temp1"), Nil)), Nil))))  *)
+(* ----------------------------------------------------------end calculations-------------------------------------------------------- *)
+(* ----------------------------------------------------------end macro functions-------------------------------------------------------- *)
+(* ----------------------------------------------------------lambda parser-------------------------------------------------------- *)
+and parse_lambda args body = (* (lambda () (+ 1 1))    (lambda () 10 20) *)
+    
+    let names = argsNames args in
+    if (List.exists (fun s-> (List.exists (fun r-> r=s ) reserved_word_list) ) names) 
+    then raise X_syntax_error
+    else
+        if isSimple args (* args.last=Nil || arg=Nil *)
+        then  (* case lambdaSimple *)
+            (match body with 
+            | Nil -> raise X_syntax_error
+            | Pair(bodyExp, Nil) ->  LambdaSimple(names, tag_parse bodyExp)
+            | _-> LambdaSimple(names, parse_sequence body) ) 
+
+        else (* case LambdaOpt *)
+            (match args with 
+            | Symbol(name) -> if List.mem name reserved_word_list
+                                  then raise X_syntax_error
+                                  else (match body with 
+                                       | Nil -> raise X_syntax_error1
+                                       | Pair(bodyExp, Nil) -> LambdaOpt([], name, tag_parse bodyExp)
+                                       | _-> LambdaOpt([], name, parse_sequence body)    (*case variadic*) )
+                                  
+            | Pair(a, b) ->  
+                      let lastArg = lastElement names in 
+                      let reversedList = (List.rev names) in
+                      let tailedList = (List.tl reversedList) in
+                      let shortedList = (List.rev tailedList) in (* = argsNames without last element *)
+                      (match body with 
+                      | Nil -> raise X_syntax_error
+                      | Pair(bodyExp, Nil) -> LambdaOpt(shortedList, lastArg, tag_parse bodyExp)
+                      | _-> LambdaOpt(shortedList, lastArg, parse_sequence body) )
+            | _ -> raise X_syntax_error )
+
+  (* (lambda vdic (consrec* vdic))
+  args = Symbol("vdic")
+  body = Pair(Pair(Symbol("consrec*"), Pair(Symbol("vdic"), Nil)), Nil) *)
+(* Pair (Symbol "lambda",Pair (Symbol "vdic",Pair (Pair (Symbol "consrec*", Pair (Symbol "vdic", Nil)), Nil))) *)
+
+and parse_sequence exps = 
+      (match exps with
+      | Nil -> Const(Void)
+      | Pair(single, Nil) -> tag_parse single
+      | Pair(a,b) -> Seq(List.map tag_parse (pair_to_list exps))    (* case list of element *)
+      | _-> raise X_syntax_error1)
+
+
+and argsNames args = 
+    match args with 
+    | Symbol(name) -> [name] 
+    | _-> List.map (fun arg-> (match arg with 
+                        | Symbol(name) -> name 
+                        | _-> raise X_syntax_error1)) 
+             (pair_to_list args)
+    
+
+and isSimple args =
+    match args with 
+    | Nil -> true 
+    | Pair(Symbol _, Symbol _) -> false
+    | Pair(Symbol _, rest) -> isSimple rest
+    | Symbol(_) -> false  (* args is not a list but a var *)
+    | _ -> raise X_syntax_error1
+    ;;
+
+let tag_parse_expressions sexprList = List.map tag_parse sexprList ;;
+
 
-  
-end;; (* struct Tag_Parser *)
+end;;(*  struct Tag_Parser *)
 
